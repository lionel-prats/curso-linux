VIDEO 18 

El sistema de ficheros esta estructurado de manera jerarquica 
Las carpetas y los ficheros se distribuyen en forma de arbol
Tenemos una carpeta principal (carpeta o directorio raiz) y a partir de ahi empiezan a colgar el resto de directorios y archivos, con sus correspondientes subcarpetas y archivos

1) Instalamos la utilidad tree (no viene por defecto) para poder explorar el sistema de ficheros desde la terminal vvv 

sudo apt install tree

*** ejecute el comando 'tree /' (apuntando al directorio raiz) antes de la instalacion y comprobe que la utilidad no existe por default vvv

ejecucion -> tree / 

return -> Command 'tree' not found, but can be installed with:
sudo snap install tree # version 1.8.0+pkg-3fd6, or 
sudo apt install tree  # version 2.0.2-1 
See 'snap info tree' for additional versions.

*** una vez instalada la utilidad vvv 

tree / -> nos lista todo el arbol a partir de / 

tree -L 1 / -> lista la estructura a partir del 1er nivel (-L), solo un nivel (1), a partir del directorio raiz (/)

tree -L 2 /

----------------------------------------

VIDEO 19

pwd (print working directory) -> para obtener la ruta absoluta del directorio donde nos encontramos

* las rutas hacen referencia a un directorio o a un archivo dentro de nuestro sistema de ficheros

* return == /home/lionel -> cuando abrimos la shell por defecto nos situa (dentro del sistema de ficheros) en la carpeta /home, en el directorio de trabajo del usuario que está ejecutando la propia shell.
Cada uno de los usuarios del sistema Linux normalmente va a tener un directorio asociado dentro de /home.
Dentro de su carpeta, cada usuario tiene permisos plenos, fuera de ahi (por ejemplo en niveles superiores - dentro de /home y/o de otros directorios del mismo nivel, 1er nivel de /, no va a tener esos priviliegios)

ls -> directorios o archivos de la carpeta donde nos encontramos en el momento de la ejecucion del comando

ls -t -> los muestra ordenados por fecha de modificacion
ls -l -> info mas detallada del contenido 
ls -lh -> igual al anterior formateando el dato del peso para hacerlo mas legible
ls -a -> vemos tambien los archivos y directorios ocultos

cd / -> para pararme en la raiz del sistema de ficheros de Linux

cd /home/lionel -> para pararme en el directorio de trabajo del usuario con el que estoy en sesion en la shell

----- 

Dentro del sistema de fiicheros de Linux hay 2 tipos de rutas:
1) Rutas absolutas -> siempre parten desde la raiz (/) -> cd /home/lionel/Desktop
2) Rutas relativas ->

. .. -> son 2 archivos ocultos que siempre estan dentro de un directorio, aunque aparentemente este vacio 

. -> hace referencia al directorio actual (una especie de enlace al directorio actual)
.. -> hace referencia al directorio anterior

cd -> asi solo sirve para pararnos en nuestro directorio de trabajo sea donde sea que nos encontremos en el sistema de ficheros de Linux
cd ~ -> hace lo mismo que cd 
cd - -> vuelve al lugar inmediatamente anterior donde estabamos parados dentro del directorio de ficheros

----------------------------------------

VIDEO 20

Ficheros y directorios ocultos -> por norma general, van a ser archivos y directorios de configuracion (suelen tener informacion de configuracion)

en /home/lionel 

.bash_history -> todo el historial de comandos que nosotros vamos ejecutando dentro de la shell 
.bashrc -> fichero de configuracion de nuestra shell
.profile -> nuestra configuracion del perfil

*** Los ficheros en la shell no tienen extension 
*** El propio SO Linux no utiliza las extensiones para nada

----------------------------------------

21. Creación de ficheros y editores de texto

mkdir test -> creo una nueva carpeta en el lugar donde estoy parado

*** Dentro del SO Linux (al igual que en Windows) tenemos editores de texto que vienen por defecto (aplicaciones que estan dentro de nuestro SO).

*** En Linux tenemos un monton de editores que podemos usar en la shell y que vienen por defecto en el SO (uno de los mas populares es pico) 

Algunos editores de texto por default:
- pico 
- nano 
- vi (tuve que forzar el cierre de la terminal porque no me funciono ni q ni q+Enter)
- emacs (no viene por defecto - ver comando en instalaciones.txt)

emacs --help -> para buscar en la consola info acerca del editor
emacs -nw -> para usar el editor desde la consola (omitimos la interfaz grafica por default)
*** pude salir con Ctrl+x/Ctrl+c

pico fichero_de_prueba.txt -> para abrir un archivo existente desde la consola y editarlo (con el editor nativo pico) 

----------------------------------------

VIDEO 22

- EL SO no va a interpretar las extensiones para absolutamente nada

file Desktop -> nos indica si se trata de un directorio o fichero (y si es fichero, de que tipo: datos, imagenes, etc)

cat auth.log -> imprime por consola el contenido de un fichero o archivo

lionel@lionel-ubuntu:/var/log$ more auth.log
-> nos sirve para contenidos extensos de ficheros -> nos muestra desde el inicio del contenido y solo lo que cabe en la pantalla de la shell, luego podemos seguir bajando con Enter 

lionel@lionel-ubuntu:/var/log$ less auth.log
*** es la mejora de more (pagina el contenido del fichero)
*** tab "h" -> nos muestra el listado de acciones que podemos utilizar dentro de less (tab "q" para salir de este menu y volver atras) 
*** tab "space" -> nos muestra la pagina siguiente 
*** tab "b" -> nos muestra la pagina anterior 
*** tab "/" + string + Enter -> para buscar el substring pasado como argumento en la pagina actual del contenido del texto (tab "n" para ver mas coincidencias en paginas siguientes)
*** tab "g" -> para ir al inicio del fichero 
*** tab "shift" + "g" -> para ir al final del fichero
*** ↓↑ -> para movernos para arriba o para abajo de a un renglon
*** tab "q" -> para salir de la utilidad

----------------------------------------

VIDEO 23 

cp nombre_fichero_copiado nombre_fichero_resultante -> duplicar un fichero con nombre nuevo (si ya existe un fichero con el nombre del segundo argumento, lo reescribe) 

cp -i fichero fichero2 -> la consola genera una validacion si detecta que el fichero que quiero crear ya existe (si el archivo existe y en la validacion tipeo "y" se va a reescribir el archivo detectado)

cp fichero fichero2 fichero3 directorio1/ -> copio los 3 achivos en una subcarpeta del espacio donde estoy parado

cp -r directorio1/ directorio2/ -> creo la carpeta directorio2, copia de directorio1 (el parametro -r viene de recursivo)

mv fichero_mover.txt directorio1 -> para mover un fichero desde el espacio donde estoy parado hata el espacio definido en el segundo parametro

mv directorio2/ directorio1/ -> mover un directorio dentro de otro

mv directorio2/ nombrenuevo/ -> renombrar un directorio (si ya existe nombrenuevo/, directorio2/ se moverá a nombrenuevo/) 

mv fichero ficheroloco -> renombar un archivo (si ya exsite ficheroloco, su contenido va a ser reescrito con el contenido de fichero, y el archivo de fichero se va a borrar)

mv -i fichero ficheroloco -> aplico una validacion de seguridad

rm fichero -> eliminar un archivo de forma permanente

rm -r directorio -> eliminar un directorio de forma permanente (-r == recursivo, significa que se va a borrar el directorio y todo lo que pueda tener dentro)

touch ficherovacio -> para crear un fichero vacio

rm -rf piluso -> para forzar el borrado sin importar nada (sirve para archivos y directorios)

----------------------------------------

24. Búsqueda de ficheros y directorios

find -> comando para buscar archivos en todo el sistema de archivos de linux 
find /var/log /home/lionel -name auth.log -> busco la ruta completa de un archivo por nombre dentro de las dos rutas definidas de forma recursiva, es decir, dentro de los dos espacios definidos y dentro de los subdirectorios que puedan haber

find /var -name auth.log 2> /dev/null -> para eliminar los prompt de los avisos de acceso denegados que puedan aparecer (esto es, cuando encuentre algo relacionado a mi busqueda, pero que a lo que mi usuario no tenga acceso)

find /var -name auth.log -ls 2> /dev/null -> ++ info sobre el archivo ademas de la ruta completa

find . -name auth.log -> "busca en mi directorio actual y en sus subdirectorios un archivo que se llame auth.log"

find /var/log -name '*.log' -> busca en el directorio indicado y en sus subdirectorios un archivo que termine en .log

*** una carpeta es un tipo de archivo especial 

find / -name server-202 -type d -> buscar carpetas en todo el arbol de archivos de linux
find / -name curso-linux -type d 2> /dev/null

buscar una carpeta o archivo creado por un usuario en particular 
find /var/log -name "*" -user lionel
find /var/log -name "*" -user lionel 2> /dev/null 

find /home/lionel -name "*" -user lionel 2> /dev/null 

----------------------------------------

EJERCICIO: Utiliza el comando find para buscar los siguientes ficheros dentro de Linux.

Preguntas de esta tarea

1) Busca la ruta donde se encuentra el comando externo ls utilizando find. Asegúrate de eliminar los mensajes de acceso denegado que produzca el comando.

find / -name ls 2> /dev/null

2) Busca directorios de configuración del programa firefox que viene instalado por defecto en Ubuntu. El nombre de los directorios debe ser firefox (igual que el programa).

find / -name "*firefox*" -type d 2> /dev/null

3) Busca el usuario propietario del fichero shadow que se encuentra en algún lugar del sistema de ficheros de Linux excluyendo aquellos ficheros shadow que se encuentren dentro de la ruta /snap.

find / -name shadow ! -path "/snap/*" -ls 2> /dev/null
3.1) El usuario propietario del fichero es root (hablaremos más sobre esto en la sección de permisos).
3.2) El comando se divide en las siguientes partes:
3.3) find / -name shadow: Buscamos el fichero shadow en el directorio raíz
3.4) ! -path "/snap/*": Excluimos todos los resultados cuya ruta comience por /snap
3.5) -ls: Mostramos información avanzada sobre el fichero
3.6) 2> /dev/null: Eliminamos los errores de permiso denegado.

----------------------------------------

VIDEO 25

Sistema de archivos/ficheros de Linux -> Estructura de carpetas/directorios creada por defecto en Linux vvv 

lionel@lionel-ubuntu:~$ tree / -L 1 -> primer nuivel de la jerarquia
/
├── bin -> usr/bin
├── boot
├── cdrom
├── dev
├── etc
├── home
├── lib -> usr/lib
├── lib32 -> usr/lib32
├── lib64 -> usr/lib64
├── libx32 -> usr/libx32
├── lost+found
├── media
├── mnt
├── opt
├── proc
├── root
├── run
├── sbin -> usr/sbin
├── snap
├── srv
├── swapfile
├── sys
├── tmp
├── usr
└── var

1) /bin -> usr/bin
    se utilizaba historicamente para almacenar binarios de algunos comandos esenciales del sistema operativo que debian estar disponibles incluso para cosas como por ejemplo levantar el sistema, arrancar el sistema o repararlo.
    A dia de hoy, este directorio ya no existe propiamente, entonces realmente es un enlace simbolico (tambien se suele llamar soft link)
    Seria lo mismo que un acceso directo en Windows, es decir, es un enlace que va a apuntar a otra carpeta dentro de nuestro sistema de ficheros, /usr/bin
    A dia de hoy, todos esos binarios esenciales que almacenaba, estan dentro de la carpeta /user/bin
2) /boot
    continene los archivos que se utilizan para arrancar el SO
    concretamente va a contener archivos del Kernel de Linux (tambien denominados archivos del cargador de arranque) y dependiendo del software (distribucion (?)) que utilizemos para cargar el arranque seran los ficheros y directorios que contendra (del Kernel (?))
    Linux utiliza un cargador de arranque que se llama grub (cd /boot/grub)
3) /cdrom
   esta ahi por razones historicas
   hoy practicamente no utilizamos cdrom, tenemos cosas en la nube, tenemos USBs 
4) /dev
    aqui lo que tenemos son diferentes interfaces tanto para leer como para escribir en diferentes dispositivos
    tenemos incluso interfaces para escribir por pantalla en la propia terminal
    estas interfaces son una especie de ficheros especiales (lo veremos mas adelante)
5) /etc
    va a contener la informacion de configuracion de nuestro SO
6) /home
    dentro se van a crear las carpetas de trabajo de cada uno de los usuarios que tenemos en el sistema donde tendra privilegios para escribir, leer ficheros y hacer todo lo que quiera
    es la carpeta personal de cada usuario de Linux
7) /lib -> usr/lib
8) /lib32 -> usr/lib32
9) /lib64 -> usr/lib64
10) /libx32 -> usr/libx32
    todos enlaces simbolicos a subdirectorios de /usr 
    estos directorios /usr/* van a contener aquellas librerias que van a requerir los diferentes programas que tenemos dentro de nuestro SO para su funcionamiento
    /lib es otra carpeta gestionada por el SO, aunque nosotros aqui si que podriamos llegar a introducir algunas librerias si la requiriese alguno de nuestros programas
11) /lost+found
    esta carpeta tiene que ver con una utilidad que es fsck 

    fsck -> utilidad que utilizamos cuando queremos recuperar parte del sistema de ficheros que por alguna razon ha quedado inconsistente o dañado

    por ejemplo, estamos trabajano en un archivo, se corta la luz y no llegamos a guardar cambios, podemos usar este tipo de comandos para tratar de recuperar la informacion que se haya podido perder durante esta interrupcion del SO

    esta informacion que se recupera, normalmente queda almacenada en /lost+found

12) /media
    es muy similar a lo que vimos con /cdrom
    va a ser la carpeta donde en teoria vamos a montar dispositivos externos
13) /mnt
    es otro punto de montaje (mnt viene de "mount")
    esto esta creado para que nosotros montemos tambien dispositivos externos, pero mas bien esta pensado para que montemos esos dispositivos de manera manual
    es como para contar con un directorio de montaje en el que si tu tienes que montar algo de manera manual utilizando una serie de utilidades que ya veremos mas adelante, utilizes este directorio 
    es un poco redundante con /media y /cdrom 
14) /opt
    opt es la abreviacion de "optional"
    se usaba antiguamente cuando te servian el SO, para alojar programas o modulos opcionales
    hoy por default esta vacio y rara vez lo vamos a utilizar para meter algo 

15) /proc
    *** este directorio esta administrado por el sistema, no debemos tocar nada de lo que hay dentro
    *** si tiramos un ls en /proc vamos a obtener una interfaz con el Kernel
    *** aqui vamos a obtener un monton de informacion sobre como esta funcionando el Kernel y los dispositivos hardware que tenemos en nuestra maquina
    *** tenemos por ejemplo ficheros como filesystems que nos da informacion sobre los sistemas de ficheros que tenemos cargados 
    *** meminfo de informacion sobre la memoria
    *** tenemos varios ficheros que nos van a dar informacion sobre el hardware y el funcionamiento del kernel
    *** tenemos tambien cpuinfo sobre la cpu 
    *** tenemos tambien directorios con diferentes numeros 
    *** estos numeros son PIDs, pero basicamente son identificadores de procesos 
    *** cada uno de los procesos que tenemos tiene un directorio asociado dentro de /proc que contiene informacion sobre el estado en el que se encuentra en este momento, como se ha ejecutado, etc.
    *** lo que vemos dentro de /proc no es un sistema de ficheros propiamente dicho sino que se suele llamar sistema de ficheros virtual porque esta como creado sobre la marcha, en tiempo de ejecucion 

    *** si hacemos un ls -la /proc comprobamos que la mayoria de los los archivos y directorios continenen 0 bits

    lionel@lionel-ubuntu:/proc$ echo $$
    2360
    *** esto me da el PID del proceso actual, que seria la propia shell, que es un proceso dentro de nuestro SO

    lionel@lionel-ubuntu:/proc$ cd 2360
    *** entro al directorio del proceso

    lionel@lionel-ubuntu:/proc/2360$ ls -la .
    *** comprobamos que todos los archivos que figuran dentro tienen 0 bits 

    *** por eso es que se llama a lo que hay dentro de /proc un sistema de ficheros virtual, no es propiamente un sistema de ficheros

    lionel@lionel-ubuntu:/proc/2360$ less status
    *** con este comando podemos ver el estado de nuestro proceso (del 2360, status es un fichero dentro de /proc/2360) 

16) /root
    es la carpeta de trabajo del usuario root
17) /run
    aqui van a guardar informacion algunos programas que inician muy rapido cuando nosotros arrancamos el SO 
    van a almacenar informacion de runtime, informacion en tiempo de ejecucion
18) /sbin -> usr/sbin
    enlace simbolico a /usr/sbin 
    es muy similar a /usr/bin, donde tenemos binarios esenciales del sistema, pero aqui vamos a tener otro tipo de binarios que normalmente estan reservados para tareas super vitales, super esenciales dentro del SO y que por norma general solamente van a poder ejecutarlos usuarios que tengan privilegios de administracion, que sean superusuarios
19) /snap
    es un gestor de paquetes 
    es para intalar programas externos 
    cuando instalamos paquetes utilizando este gestor se van a instalar en esta ruta
20) /srv
    contiene ciertos datos de servicios, normalmente informacion que nosotros estamos sirviendo hacia afuera
    cuando nosotros instalamos ciertos softwares, como por ejemplo FTP, o cosas que esten sirviendo informacion, es posible que se cree aqui un directorio con el nombre de ese software o de ese protocolo (por ejemplo "/ftp") y tenga aqui cierta informacion que estemos sirviendo 
21) /swapfile
    hace el swap de la memoria RAM a disco para no saturar la memoria RAM 
    cuando un proceso tiene mucha informacion almacenada comienza a paginar, comienza a tomar informacion que esta en memoria RAM y la empieza a volcar a disco
    concretamente la vuelca a este fichero /swapfile
    es un fichero grande (ls -lah 2.1G) donde el SO va haciendo swaping constantemente desde memoria RAM a disco
22) /sys
    otro directorio propio del SO
    este directorio nos sirve tambien de interfaz con el Kernel
    aqui tenemos algunos ficheros con parametros de configuracion que incluso podemos llegar a modificar para dar algunas instrucciones al kernel: cambiar ciertos comportamientos, etc. (esto representa una interfaz, una manera de transmitir informacion a ciertos procesos que funcionan dentro del kernel para que realizen algunas tareas)
    aqui rara vez vamos a modificar ficheros, y cuando lo hagamos debemos tener muy claro lo que estamos haciendo
23) /tmp
    directorio temporal pensado para que el usuario almacene en el cualquier tipo de dato que simplemente lo este descargando 
    en muchas ocasiones este directorio se borra cuando reiniciamos el equipo
    todos los usuarios tienen permisos completos sobre este directorio
24) /usr
    es el directorio mas grande de todos los que hemos visto y el mas grande dentro de la jerarquia de Linux 
    tendremos todo lo que son programas, configuraciones, librerias, todo lo que es propio de los usuarios 
25) /var
aqui tenemos datos que cambian con frecuencia

----------------------------------------

26. Caso práctico: Análisis forense del fichero swapfile

emacs /etc/passwd -> para leer un fichero con informacion de todos los usuarios del nuestra maquina Linux con el editor instalado emacs

Ctrl + z -> envia el proceso anterior a segundo plano

ps -> podemos observar el PID, que es un identificador de procesos vvv
PID   TTY       TIME CMD
2340  pts/0 00:00:00 bash
14080 pts/0 00:00:01 emacs
14151 pts/0 00:00:00 ps

prlimit --as=1000 --pid 14080
-> con esto estamos limitando la cantidad de memoria RAM que puede consumir este proceso emacs (ya que en comando incluimos el identificador PID)
-> cuando llegue al limite (1000 == 1mb) emacs va a tratar de volcar la informacion que no puede mantener en memoria RAM a disco (al fichero swapfile)

fg -> con este comando vuelvo a traer el proceso emacs a primer plano

sudo cp /swapfile /home/lionel/Desktop/
-> sudo nos permite elevar prvilegios
-> con este comando hice una copia del fichero /swapfile en el escritorio de mi maquina Linux 

sudo chmod 755 /home/lionel/Desktop/swapfile 
-> con este comando le doy suficientes permisos al fichero en mi Desktop para poder cerrar la shell 

cat /etc/passwd -> cat imprime el contenido de un archivo en la terminal

*** el ejercicio consiste en hacer un copy paste del swapfile desde mi Desktop en la VM (SO Ubuntu) a mi maquina host (W10), pero no me funcionó
*** Luego, en la maquina host instala Autopsy (https://www.autopsy.com/) para hacer busquedas en el swapfile copypasteado desde la VM 

----------------------------------------

VIDEO 28 - Inodos
en la raiz del arbol de ficheros, con cd home/lionel me paro en el home de mi usuario

Los datos relacionados a un directorio o fichero, como ser propietario, permisos, fecha de creacion, tamaño, etc, se denominan METADATOS
Todos estos metadatos tienen que estar almacenados en alguna parte 
La estructura que va a almacenar esta informacion se denomina INODO
Todos los ficheros y directorios que tengamos dentro de nuestro sistema de ficheros en Linux van a tener asociado un INODO
Estos INODOS van a contener la informacion de contexto, los metadatos, asociados a los archivos o directorios
Cada inodo va a tener un identificador, que va a ser el que va a usar el SO por detras para gestionar todos los ficheros del sistema de ficheros

df -i 
-> nos devuelve informacion de todos los sistemas de ficheros existentes en nuestra VM
-> en Linux podemos tener varios sistemas de ficheros
-> el principal es el que esta montado en la raiz (Mounted on), que es el sistema con el que venimos trabajando vvv
Filesystem   Inodes   IUsed    Ifree IUse%   Mounted on 
/dev/sda3   1277952  225526 10524426   18%   /

ls -i fichero.txt -> para acceder al nro de inodo de fichero.txt

stat fichero.txt -> para ver info del fichero que nos proporciona su inodo (identificador = 529482)

sudo debugfs -R "stat <529482>" /dev/sda3
-> con sudo ejecutamos un comando con privilegios de administrador
-> nos muestra la misma info que el comando anterior pero presentada de otra manera
-> 529482 es el indo (identificador unico) del fichero

----------------------------------------

VIDEO 28 - Inodos (REPASO)

df -i 
-> nos devuelve informacion de todos los sistemas de ficheros existentes en nuestro SO 
-> en Linux podemos tener varios sistemas de ficheros 
-> el principar es el que esta montado en la raiz (Mounted on == /)   
Filesystem      Inodes  IUsed   IFree IUse% Mounted on
/dev/sda3      1277952 228000 1049952   18% /

ls -i fichero.txt -> para acceder al nro de inodo de un fichero en particular

stat fichero.txt -> para visualizar los metadatos de un fichero en particular

sudo debugfs -R "stat <529047>" /dev/sda3
-> nos muestra la misma info que el comando anterior pero presentada de otra manera

sudo debugfs -R "stat <12>" /dev/sda3
-> para ver los metadatos del archivo swapfile en la raiz de nuesto SO

--------------------

VIDEO 29 - Dentries

Dentries -> Directory Entries

ls -lid curso-linux -> para acceder al inodo de un directorio 

stat curso-linux

ls -lia /home/lionel

--------------------

VIDEO 30 - Enlaces simbólicos (Soft Links)

ls -li / -> para acceder a los inodos e informacion de todos los directorios y archivos de un directorio

ls -lid / -> para acceder al inodo e informacion de un directorio

Ctrl + r 
-> para buscar el substring mas reciente en el historial de comandos
-> con mas Ctrl + r me voy moviendo hacia atras en los comandos que contengan ese substring

pwd -> para saber la ubicacion en la que estoy parado dentro del sistema de ficheros de Linux 

PRACTICA: crear enlace simbolico de un fichero vvv 
1) En /home/lionel/Desktop creo el fichero "fichero_escritorio.txt"
2) Retrocedo un nivel y desde /home/lionel creo un enlace simbolico al archivo creado en 1) vvv
ln -s Desktop/fichero_escritorio.txt fich_sim 
-> -s == soft link
-> enlace simbolico creado usando una ruta relativa (Desktop/fichero)

3) Desde /home/lionel tiro un cat fich_sim y compruebo que accedo al contenido de fichero_escritorio.txt, por lo tanto el enlace simbolico funciona

* tambien se puede crear un enlace sombolico con rutas absolutas vvv
ln -s /home/lionel/Desktop/fichero_enlazado enlace

* tambien se pueden crear accesos simbolicos a directorios

--------------------

VIDEO 31 - Enlaces duros (Hard Links)

- Los Hard Links son solo accesos o enlaces para ficheros 

- un hard link se crea con la utilidad ln (igual que los soft links)

info ln -> para ver documentacion de una utilidad (ln es una utilidad)

lionel@lionel-ubuntu:~$ ln Desktop/fichero_con_hard_link.txt hard_link
*** creo el hardlink "hard_link" al archivo Desktop/fichero_con_hard_link.txt

- El nro de inodo de un hardlink coincide con el nro de inodo del archivo al que hace referencia 
*** ls -li para acceder a los nros de inodos de ficheros y directorios vvv 

lionel@lionel-ubuntu:~$ cat Desktop/fichero_enlazado hardlink enlace
fichero de prueba

fichero de prueba

fichero de prueba

lionel@lionel-ubuntu:~$ ls -li Desktop/fichero_enlazado hardlink enlace
525321 -rw-rw-r-- 2 lionel lionel 19 feb 19 22:13 Desktop/fichero_enlazado
525277 lrwxrwxrwx 1 lionel lionel 37 feb 19 22:14 enlace -> /home/lionel/Desktop/fichero_enlazado
525321 -rw-rw-r-- 2 lionel lionel 19 feb 19 22:13 hardlink
*** como se ve, un softlink tiene su propio inodo, en cambio un hardlink comparte el inodo con su referencia
*** esto quiere decir que un hardlink es una referencia al mismo inodo del fichero al que esta enlazado 
*** a efectos practicos, un hardlink es como si fuese el mismo fichero al que esta enlazado 

- luego, el profesor demuestra que, luego de eliminar el fichero original con rm, el hardlink sigue funcionando y se puede acceder al contenido del fichero eliminado (en la misma situacion, un softlink se rompe)
- esto es porque el hardlink sigue referenciando al nro de inodo original del fichero, y en ese inodo aparecen los bloques donde esa informacion del fichero estaba en memoria

.  -> hardlink al directorio actual (mismo inodo)
.. -> hardlink al directorio padre de un directorio (mismo inodo)

--------------------

VIDEO 32 - Wildcards

Los wildcards son un conjunto de simbolos que nos van a permitir referenciar un grupo de ficheros utilizando patrones en sus nombres 

1) * == cualquier caracter y cualquier cantidad de caracteres

lionel@lionel-ubuntu:~/Desktop/curso-linux$ cat pruebas/fichero*
contenido del fichero1.txt
contenido del fichero2.txt
contenido del fichero3.txt
contenido del fichero4.txt
contenido del fichero5.txt

lionel@lionel-ubuntu:~$ ls -l D*
Desktop:
...
Documents:
...
Downloads:
...

lionel@lionel-ubuntu:~$ ls -d D*
Desktop  Documents  Downloads

2) ? == cualquier caracter, pero unicamente un caracter

lionel@lionel-ubuntu:~$ cat Desktop/curso-linux/pruebas/fichero?.txt
contenido del fichero1.txt
contenido del fichero2.txt
contenido del fichero3.txt
contenido del fichero4.txt
contenido del fichero5.txt

3) 
lionel@lionel-ubuntu:~$ cat Desktop/curso-linux/pruebas/fichero[12399].txt
contenido del fichero1.txt
contenido del fichero2.txt
contenido del fichero3.txt
-- NO fichero4.txt
-- NO fichero5.txt
-- NO fichero99.txt
lionel@lionel-ubuntu:~$ 

lionel@lionel-ubuntu:~$ cat Desktop/curso-linux/pruebas/fichero[!123].txt
contenido del fichero4.txt
contenido del fichero5.txt
-- NO fichero1.txt
-- NO fichero2.txt
-- NO fichero3.txt
-- NO fichero99.txt

4)
lionel@lionel-ubuntu:~$ cat Desktop/curso-linux/pruebas/fichero[[:digit:]].txt
contenido del fichero1.txt
contenido del fichero2.txt
contenido del fichero3.txt
contenido del fichero4.txt
contenido del fichero5.txt

*** class == conjunto de caracteres determinado vvv
digit
alpha 
alnum
upper
lower

lionel@lionel-ubuntu:~$ ls -ld [[:upper:]]*
drwxr-xr-x 4 lionel lionel 4096 feb 24 00:11 Desktop
drwxr-xr-x 2 lionel lionel 4096 sep  5 15:06 Documents
drwxr-xr-x 2 lionel lionel 4096 feb 24 00:07 Downloads
drwxr-xr-x 2 lionel lionel 4096 sep  3 22:17 Music
drwxr-xr-x 2 lionel lionel 4096 sep  3 22:17 Pictures
drwxr-xr-x 2 lionel lionel 4096 sep  3 22:17 Public
drwxr-xr-x 2 lionel lionel 4096 sep  3 22:17 Templates
drwxrwxr-x 2 lionel lionel 4096 sep  5 12:53 Test
drwxr-xr-x 2 lionel lionel 4096 sep  3 22:17 Videos
*** todos los nombres de directorios que empiezen con una letra mayuscula

lionel@lionel-ubuntu:~$ cat fichero[![:digit:]].txt
contenido del ficheroC

lionel@lionel-ubuntu:~$ cat fichero[[:digit:]].txt
Contenido del fichero 7

--------------------

TAREA 32 - Wildcards

Utiliza los wildcards presentados en la sección anterior para realizar las siguientes búsquedas de ficheros y directorios.

Preguntas de esta tarea

Busca todos los ficheros que se encuentran en /usr/bin y terminan por un número.
lionel@lionel-ubuntu:~$ ls -l /usr/bin/*[[:digit:]]
lionel@lionel-ubuntu:~$ find /usr/bin/ -maxdepth 1 -name *[[:digit:]] 2> /dev/null
SOLUCION -> find /usr/bin -name '*[[:digit:]]'

Busca todos los ficheros en el sistema de ficheros de Linux que contenga dos caracteres _ en el nombre y terminen en .txt.
lionel@lionel-ubuntu:~$ find / -name *_*_*.txt 2> /dev/null
SOLUCION -> find / -name '*_*_*.txt' 2> /dev/null
            
Busca todos los ficheros en /var/log que no terminen en .log
lionel@lionel-ubuntu:~$ ls -l /var/log/*.log
lionel@lionel-ubuntu:~$ find /var/log/ -maxdepth 1 -name *.log 2> /dev/null
lionel@lionel-ubuntu:~$ find /var/log/ -name *[!'.log'] 2> /dev/null
SOLUCION -> find /var/log -name '*[!.log]' 2> /dev/null
            find /var/log/ -name '*[!.log]' 2> /dev/null

--------------------

VIDEO 33 - Shell Expansions 

lionel@lionel-ubuntu:~$ type echo
echo is a shell builtin
lionel@lionel-ubuntu:~$ 

*** el comando echo viene implementado en la shell por defecto
*** imprime por pantalla el texto que le proporcionemos como argumento
*** realmente, lo que hace echo es redirigir el argumento recibido a lo que se denomina standard output, que es un fichero especial del que ya hablaremos

~ -> referencia nuestro directorio de trabajo, nuestro directorio /home

lionel@lionel-ubuntu:~$ echo ~
/home/lionel
*** la shell expande "~" a "/home/lionel"

lionel@lionel-ubuntu:~$ echo /*/log
/dev/log /run/log /var/log
*** listo todos los directorios dentro de la raiz, que contengan un subdirectorio /log

lionel@lionel-ubuntu:/$ echo $((2 + 2))
4

lionel@lionel-ubuntu:/$ echo $((2 ** 3))
8

lionel@lionel-ubuntu:~$ cat fichero$((1+1))*
contenido fichero2.txt

Brace expansins ("{", "}")

lionel@lionel-ubuntu:~$ echo fichero{1,2,3,Katopodis}.txt
fichero1.txt fichero2.txt fichero3.txt ficheroKatopodis.txt

lionel@lionel-ubuntu:~$ echo fichero{10..15}.txt
fichero10.txt fichero11.txt fichero12.txt fichero13.txt fichero14.txt fichero15.txt

lionel@lionel-ubuntu:~$ mkdir dir{1..5}
*** creo en simultaneo /dir1, /dir2, /dir3, /dir4 y /dir5

lionel@lionel-ubuntu:~$ echo {A..z}
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [  ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z

lionel@lionel-ubuntu:~$ echo {z..A}
z y x w v u t s r q p o n m l k j i h g f e d c b a ` _ ^ ]  [ Z Y X W V U T S R Q P O N M L K J I H G F E D C B A

lionel@lionel-ubuntu:~$ echo texto{A{1,2},B{3,4}}final
textoA1final textoA2final textoB3final textoB4final

lionel@lionel-ubuntu:~$ mkdir logs
lionel@lionel-ubuntu:~$ cd logs/

lionel@lionel-ubuntu:~/logs$ mkdir {2024..2030}-{01..12}
*** creé carpetas desde 2024-01 hasta 2030-12 (84 carpetas)

lionel@lionel-ubuntu:~/logs$ rmdir {2024..2030}-{01..12}
*** borré las 84 carpetas anteriores

--------------------

VIDEO 34 - Command Substitution 

lionel@lionel-ubuntu:~$ which cat
/usr/bin/cat
* which  returns the pathnames of the files (or links) which would be executed in the current environment (documentacion obtenida con info which)

lionel@lionel-ubuntu:~$ type cat
cat is /usr/bin/cat

- Buscamos pasar la salida de un ejecutable como parametro de entrada a otro ejecutable vvv

lionel@lionel-ubuntu:~$ ls -la which cat
ls: cannot access 'which': No such file or directory
ls: cannot access 'cat': No such file or directory
*** aca vemos que la terminal interpreta a which como el nombre de un fichero o directorio, y al no encontrarlo tira error

lionel@lionel-ubuntu:~$ ls -al $(which cat)
-rwxr-xr-x 1 root root 35280 feb  7  2022 /usr/bin/cat
*** con esta expansion de la shell (command substitution), le pasamos la salida de la ejecucion del ejecutable which como parametro de entrada a la ejecucion del comando ls 

lionel@lionel-ubuntu:~$ ls -al /usr/bin/cat
-rwxr-xr-x 1 root root 35280 feb  7  2022 /usr/bin/cat
*** en este caso, el comando anterior es equivalente a este
*** el comando cat es un binario 

lionel@lionel-ubuntu:~$ python3
Python 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 

*** se abre el interprete de Python 
*** ENTIENDO que Python viene instalado por default en Ubuntu  (?)
*** exit() para salir del interprete de python

lionel@lionel-ubuntu:~$ python3 -c 'print("Hola mundo")'
Hola mundo
*** se va a ejecutar el codigo print("Hola mundo") interpretado como codigo en python y la salida va a mostrarse en el stdout

lionel@lionel-ubuntu:~$ echo $(python3 -c 'print("Hola mundo")')
Hola mundo

*** en versiones antiguas de bash, que es el tipo de shell que estamos utilizando ahora, en lugar de usar el patron $() para indicar un command substitution, se utilizaban las ``
*** sigue habiendo retrocompatibilidad vvv

lionel@lionel-ubuntu:~$ ls -la `which cat`
-rwxr-xr-x 1 root root 35280 feb  7  2022 /usr/bin/cat
lionel@lionel-ubuntu:~$ ls -la $(which cat)
-rwxr-xr-x 1 root root 35280 feb  7  2022 /usr/bin/cat

--------------------

VIDEO 35 - Comillas en la Shell de Linux

todo lo que introduzcamos entre "" dentro de la shell de Linux va a provocar que pierdan su significado todos los caracteres especiales, menos 3 vvv
- $
- \
- `

Comillas dobles vvv 
-------------------

lionel@lionel-ubuntu:~$ echo fichero*
fichero1.txt fichero2.txt ficheroC.txt
*** el wild card * es interpretado correctamente

lionel@lionel-ubuntu:~$ echo "fichero*"
fichero*
*** en este caso, * no es interpretado como un wildcard por la shell

lionel@lionel-ubuntu:~$ echo "La ruta de cat es: $(which cat)"
La ruta de cat es: /usr/bin/cat
*** el command substitution $() se sigue interpretando correctamente

lionel@lionel-ubuntu:~$ echo "La ruta de ls es: `which ls`"
La ruta de ls es: /usr/bin/ls
*** el command substitution `` se sigue interpretando correctamente

Comillas simples vvv 
--------------------

- Las '' sirven para eliminar el comportamiento de todos los caracteres especiales que hay en la shell, incluidos $ \ ` vvv 

lionel@lionel-ubuntu:~$ echo 'La ruta de ls es: `which ls`'
La ruta de ls es: `which ls`
*** aca vemos que el command substitution pierde su significado

--------------------

VIDEO 36 - Escapando caracteres especiales

\ -> este caracter se denomina CARACTER DE ESCAPE vvv

lionel@lionel-ubuntu:~$ echo "esto es una expansion -> $(which cat), pero si la escapo con \\ pierde su significado -> \$(which cat)"
esto es una expansion -> /usr/bin/cat, pero si la escapo con \ pierde su significado -> $(which cat)

lionel@lionel-ubuntu:~$ ls -la nombre\ separado2.txt 
-rw-rw-r-- 1 lionel lionel 0 mar  2 22:44 'nombre separado2.txt'

*** equivalente a vvv
lionel@lionel-ubuntu:~$ ls -la "nombre separado2.txt" 
-rw-rw-r-- 1 lionel lionel 0 mar  2 22:44 'nombre separado2.txt'
lionel@lionel-ubuntu:~$ 

-e -> codigo de control vvv
---------------------------

lionel@lionel-ubuntu:~$ echo -e "\a"
*** le estamos transmitiendo la orden al ordenador de que haga un "bit" (un sonido)

lionel@lionel-ubuntu:~$ echo "\a"
\a

lionel@lionel-ubuntu:~$ echo -e "Este texto \t \a esta tabulado"
Este texto 	  esta tabulado
*** tabula texto y se escucha el "bit"

lionel@lionel-ubuntu:~$ echo "Este texto \t \a esta tabulado"
Este texto \t \a esta tabulado
*** texto plano

lionel@lionel-ubuntu:~$ echo -e "Esta es la primera linea con una \ttabulacion \nLuego hay un salto de linea, y finalmente se escuche el \a'bit'"
Esta es la primera linea con una 	tabulacion 
Luego hay un salto de linea, y finalmente se escuche el 'bit'
*** tabulacion, salti de linea y "bit"

lionel@lionel-ubuntu:~$ echo "Esta es la primera linea con una \ttabulacion \nLuego hay un salto de linea, y finalmente se escuche el \a'bit'"
Esta es la primera linea con una \ttabulacion \nLuego hay un salto de linea, y finalmente se escuche el \a'bit'
*** texto plano

\a \t \n \b \r vvv 

lionel@lionel-ubuntu:~$ echo -e "palabra1\a palabra2\t palabra3\n palabra4\b palabra5\r palabra6"
palabra1 palabra2	 palabra3
 palabra6palabra5

--------------------

VIDEO 37 - Caso práctico: El programa vulnerable persistente 

Ejercicio:
- Tenemos un programa instalado en /usr/bin (donde tenemos la mayoria de los programas que utilizamos dentro de nuestro SO Linux, dentro de nuestra shell)
- Uno de estos programas es vulnerable: tiene un fallo de seguridad cualquiera que se puede explotar para ganar por ejemplo una elevacion de privilegios, para poder convertirte en un usuario con mas privilegios. 
- el programa implementa una backdoor, el administrador en un momento se da cuenta que alguien externo esta explotando la falla, elimina con rm el script original pero no soluciona el problema porque el atacante al acceder al script creó un hard link.

- Definicion de backdoor (chatGTP):
Una puerta trasera, conocida en inglés como "backdoor", es una funcionalidad oculta o una vulnerabilidad en un software que permite el acceso no autorizado al sistema o a los datos por parte de personas no autorizadas. Las puertas traseras pueden ser insertadas intencionalmente por el creador del software con fines legítimos, como para facilitar el acceso de mantenimiento o para propósitos de pruebas, pero también pueden ser introducidas de manera maliciosa por personas que desean acceder de forma no autorizada.
Las puertas traseras pueden ser difíciles de detectar, ya que a menudo están diseñadas para pasar desapercibidas. Sin embargo, una vez que se descubren, pueden representar un riesgo significativo para la seguridad de un sistema, ya que pueden ser explotadas por hackers o personas malintencionadas para acceder a información confidencial, causar daños o comprometer la integridad del sistema.
En resumen, una puerta trasera en un programa es una forma de acceso no autorizado que puede ser explotada para comprometer la seguridad de un sistema o acceder a datos sensibles.

*** planteo original del ejercicio vvv 
https://www.hackinglinuxexposed.com/articles/20031214.html 

Simulacion vvv

V37.1) el administrador crea el script que va a tener la falla de seguridad 
lionel@lionel-ubuntu:~$ nano vulnprog
V37.2) escribí y guardé el archivo
#! /bin/bash

read -p "Introduce un valor de entrada: " entrada

if [ "$entrada" = "backdoor" ]; then
        echo "Proporcionaste shell de root"
else
        echo "Funcionamiento normal del programa"
fi

V37.3) intento ejecutarlo escribiendo vulnprog
lionel@lionel-ubuntu:~$ vulnprog
vulnprog: command not found

V37.4) intento ejecutarlo escribiendo ./vulnprog (sugerencia chatGTP)
lionel@lionel-ubuntu:~$ ./vulnprog
bash: ./vulnprog: Permission denied

V37.5) le damos permisos de ejecucion (lo saqué de los comentarios del video)
lionel@lionel-ubuntu:~$ chmod 777 vulnprog

V37.6) repito paso 3)
ionel@lionel-ubuntu:~$ vulnprog
vulnprog: command not found

V37.7) repito paso 4)
lionel@lionel-ubuntu:~$ ./vulnprog
Introduce un valor de entrada: inputcualquiera
Funcionamiento normal del programa

lionel@lionel-ubuntu:~$ ./vulnprog
Introduce un valor de entrada: backdoor
Proporcionaste shell de root

V37.8) copio el script en /usr/bin con permisos de administrador
lionel@lionel-ubuntu:~$ sudo cp vulnprog /usr/bin/
[sudo] password for lionel: 

V37.9) chequeo la existencia y los permisos de ambos archivos 
lionel@lionel-ubuntu:~$ ls -l vulnprog /usr/bin/vulnprog 
-rwxr-xr-x 1 root   root   191 mar  3 02:41 /usr/bin/vulnprog
-rwxrwxrwx 1 lionel lionel 191 mar  3 02:36 vulnprog

V37.10) creo un hard link de /usr/bin/vulnprog en ~
lionel@lionel-ubuntu:~$ sudo ln /usr/bin/vulnprog vulnprog.hardlink

V37.11) chequeo los inodos de los 2 archivos y del hard link
lionel@lionel-ubuntu:~$ ls -lai /usr/bin/vulnprog vulnprog vulnprog.hardlink 
1049104 -rwxr-xr-x 2 root   root   191 mar  3 02:41 /usr/bin/vulnprog
 535012 -rwxrwxrwx 1 lionel lionel 191 mar  3 02:36 vulnprog
1049104 -rwxr-xr-x 2 root   root   191 mar  3 02:41 vulnprog.hardlink
*** observar que /usr/bin/vulnprog y vulnprog.hardlink apuntan a los mismos espacios de memoria

V37.12) chequeo que el hard link funciona
lionel@lionel-ubuntu:~$ ./vulnprog.hardlink
Introduce un valor de entrada: backdoor
Proporcionaste shell de root

V37.13) elimino los 2 archivos dejando solo el hardlink 
lionel@lionel-ubuntu:~$ rm vulnprog  
lionel@lionel-ubuntu:~$ sudo rm /usr/bin/vulnprog 

V37.14) chequeo que se hayan borrado correctamente los 2 archivos y que aun exista el hard link
lionel@lionel-ubuntu:~$ ls -lai vulnprog.hardlink /usr/bin/vulnprog vulnprog
ls: cannot access '/usr/bin/vulnprog': No such file or directory
ls: cannot access 'vulnprog': No such file or directory
1049104 -rwxr-xr-x 1 root root 191 mar  3 02:41 vulnprog.hardlink
*** observar que solo quedo el hard link apuntando a los mismos espacios de memoria donde apuntaba tambien /usr/bin/vulnprog

V37.15) creo un nuevo /usr/bin/vulnprog solucionando la falla de seguridad
lionel@lionel-ubuntu:~$ sudo nano /usr/bin/vulnprog

#!/bin/bash
read -p "Introduce un valor de entrada: " entrada
echo "Funcionamiento normal del programa"

V37.16) verifico existencia y permisos del nuevo archivo y del hard link
lionel@lionel-ubuntu:~$ ls -lai /usr/bin/vulnprog vulnprog.hardlink 
1136253 -rw-r--r-- 1 root root 104 mar  3 02:57 /usr/bin/vulnprog
1049104 -rwxr-xr-x 1 root root 191 mar  3 02:41 vulnprog.hardlink

V37.17) doy permisos de ejecucion al nuevo script
lionel@lionel-ubuntu:~$ sudo chmod 777 /usr/bin/vulnprog 

V37.18) ejecuto el nuevo script y chequeo que se soluciono la falla de seguridad
lionel@lionel-ubuntu:~$ /usr/bin/vulnprog
Introduce un valor de entrada: backdoor
Funcionamiento normal del programa

V37.19) vuelvo a ejecutar el hardlink del script eliminado y compruebo que puedo seguir ejecutando el codigo fuente del script original y explotando las fallas de seguridad
lionel@lionel-ubuntu:~$ ./vulnprog.hardlink 
Introduce un valor de entrada: backdoor
Proporcionaste shell de root

--------------------

Prueba con script Python:

lionel@lionel-ubuntu:~$ nano app.py

print("Hola")

lionel@lionel-ubuntu:~$ ls -l app.py 
-rw-rw-r-- 1 lionel lionel 63 mar  3 03:12 app.py
lionel@lionel-ubuntu:~$ chmod 777 app.py 
lionel@lionel-ubuntu:~$ ls -l app.py 
-rwxrwxrwx 1 lionel lionel 63 mar  3 03:12 app.py

lionel@lionel-ubuntu:~$ ./app.py 
./app.py: line 1: syntax error near unexpected token `"Hola"'
./app.py: line 1: `print("Hola")'

*** No funcionó correctamente 

--------------------

VIDEO 39 - I/O Redirection 

- Input 
- Output 
- Redirection

- cuando ejecutamos el comando ls, este nos proporciona una salida

- normalmente, las utilidades que tenemos de la shell de linux, y en general, dentro de linux, van a sacarnos 2 tipos de informacion:
a) la propia informacion, es decir, los resultados del programa 
b) mensajes de estado y de error que nos van a indicar si el comportamiento del programa ha sido adecuado

lionel@lionel-ubuntu:~$ ls fichero_fantasma.txt
ls: cannot access 'fichero_fantasma.txt': No such file or directory
*** aqui ls nos muestra por pantalla informacion (en este caso, un mensaje de estado) que nos dice "no puedo acceder al fichero fichero_fantasma.txt porque este no existe en tu directorio actual"

Lo que ocurre por detras con todas estas utilidades para que generen las salidas 
-------------------------------------------------------
que nos proporcionan por pantalla vvv
-------------------------------------

- todos estos programitas, como por ejemplo ls, lo que estan haciendo para sacar la salida por pantalla, es escribir dicha salida en un fichero especial llamado stdout (/dev/stdout), que en realidad veremos que es un enlace simbolico a /proc/self/fd/1, y en ultima instancia a /dev/pts/0 vvv

lionel@lionel-ubuntu:~$ ls -lai /dev/stdout /dev/stdin /dev/stderr
391 lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stderr -> /proc/self/fd/2
389 lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdin -> /proc/self/fd/0
390 lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdout -> /proc/self/fd/1
*** como se ve en los 3 casos, la "l" antes de los permisos nos indica que en realidad son enlaces simbolicos 

- siguiendo el caminito de stdout vvv 

lionel@lionel-ubuntu:~$ ls -lai /dev/stdout
390 lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdout -> /proc/self/fd/1
*** enlace simbolico a /proc/self/fd/1

lionel@lionel-ubuntu:~$ ls -lai /proc/self/fd/1
109962 lrwx------ 1 lionel lionel 64 mar  3 13:15 /proc/self/fd/1 -> /dev/pts/0
*** enlace simbolico a /dev/pts/0

lionel@lionel-ubuntu:~$ ls -lai /dev/pts/0
3 crw--w---- 1 lionel tty 136, 0 mar  3 13:15 /dev/pts/0

- /dev/pts/0 es un tipo de fichero especial detro de linux
- observar que antes de los permisos viene referenciado con una "c", que indica que se trata de un CARACTER DEVICE FILE
- /dev/pts/0 es un tipo de fichero especial que va a servir de interfaz, en este caso con la terminal, y mas concretamente, con la pantalla
- es decir, va a recibir ciertos caracteres (por ejemplo el texto de salida que escribe y le envia la funcionalidad ls) y /dev/pts/0 va a mostrarlo por pantalla
- entonces /dev/pts/0 es un fichero especial al que nosotros le proporcionamos un texto, y que nos servira de interfaz, estara conectado con la pantalla de nuestro equipo, de nuestra terminal concretamente, y nos imprimira ese texto en la terminal

Flujo de salida:
a) ls ... -> escribe y envia texto a /dev/stdout
b) /dev/stdout, que es soft link a /proc/self/fd/1, redirecciona este texto 
c) /proc/self/fd/1, que es soft link a /dev/pts/0, redirecciona este texto
d) /dev/pts/0, que es un fichero especial, concretamente un CARACTER DEVICE FILE, que esta conectado a la pantalla de la terminal, imprimira el texto que originalmente genero la utilidad ls

- Por otro lado, los mensajes de estado y de error que pueda generar una utilidad se envian a /dev/stderr
*** uso el operador ";" para encadenar comandos y el caracter especial "\" para que sea mas legible (S2-TL-V12 curso Docker de holamundo) vvv

lionel@lionel-ubuntu:~$ \
> ls -lai /dev/stdout;\
> ls -lai /dev/stderr;\
> ls -lai /proc/self/fd/1;\
> ls -lai /proc/self/fd/2;\
> ls -lai /dev/pts/0
390 lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdout -> /proc/self/fd/1
391 lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stderr -> /proc/self/fd/2
239888 lrwx------ 1 lionel lionel 64 mar  3 14:25 /proc/self/fd/1 -> /dev/pts/0
239895 lrwx------ 1 lionel lionel 64 mar  3 14:25 /proc/self/fd/2 -> /dev/pts/0
3 crw--w---- 1 lionel tty 136, 0 mar  3  2024 /dev/pts/0
*** observar que tanto el enlace simbolico /dev/stdout como el enlace simbolico /dev/stderr, en ultima instancia apuntan al mismo fichero especial /dev/pts/0, y por lo tanto la interfaz va a ser exactamente la misma
*** por motivos de retrocompatibilidad, por motivos de diferenciar bien a donde vamos a mandar los mensajes de salida correctos y los mensajes de error, tenemos 2 enlaces simbolicos que son distintos (stderr para los mensajes de error y stdout para las salidas standard del propio comando) (con esto vemos cual es una de las funciones que tienen los enlaces simbolicos)

lionel@lionel-ubuntu:~$ tree -L 100 /dev/pts
/dev/pts
├── 0
├── 1
├── 2
├── 3
└── ptmx

0 directories, 5 files
*** observar que busque en 100 subniveles, entonces compruebo que /dev/pts/ solo contiene 5 ficheros

- Ademas de la salida standard y la salida de error, tenemos tambien entradas que son utiles para los comandos
- hay veces que ciertos comandos nos van a solicitar que nosotros metamos texto utilizando el teclado
- este tipo de entrada se denomina standard input que van a tener el fichero especial asociado /dev/stdin (que en verdad es un soft link que tambien apunta en ultima instancia a /dev/pts/0)

lionel@lionel-ubuntu:~$ \
> ls -lai /dev/stdin;\
> ls -lai /proc/self/fd/0;\
> ls -lai /dev/pts/0
389 lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdin -> /proc/self/fd/0
242736 lrwx------ 1 lionel lionel 64 mar  3 14:38 /proc/self/fd/0 -> /dev/pts/0
3 crw--w---- 1 lionel tty 136, 0 mar  3 14:38 /dev/pts/0

- curiosamente (como veremos en siguientes clases) este fichero especial /dev/pts/0 se encuentra tambien asociado con nuestro teclado y nos va a hacer de interfaz para que nosotros podamos presionar teclas (introducir texto por teclado) y el lo proporcione a ciertos comandos que reciben este standard input por parte del usuario

- una vez entendido que los programas van a redirigir el texto a stdout, stderr e incluso van a pedir los de stdin para que los introduzca el usuario veremos como modificar la salida standard (stdout), los estados errores (stderr) o los inputs (stdin), es decir redireccionar esas entradas y salidas hacia donde queramos

--------------------

VIDEO 40 - Standard Output (stdout) Redirection

Ahora que sabemos lo que pasa por detras cuando ejecutamos un comando en linux y su salida se muestra por pantalla, ahora veremos como podemos redirigir esa salida a donde a nosotros nos interese

Como controlar el standard output de un comando, es decir, la salida standard standard de un 
--------------------------------------------------------------------------------------------
comando vvv
-----------

\
ls fichero1.txt;\
ls -l fichero1.txt;\
ls -la fichero1.txt;\
ls -lah fichero1.txt;\
ls -lai fichero1.txt;

Operador redireccion (>)
------------------------

- el operador redireccion (>) nos permite redireccionar el standard output de un comando (no sirve para redirigir el stderr) vvv

lionel@lionel-ubuntu:~$ ls -lah > salida_ls.txt
lionel@lionel-ubuntu:~$ code salida_ls.txt 
*** en vez de mostrarse el stdout por pantalla, se creó el fichero salida_ls.txt con el stdout de ls -lah (luego, a modo de prueba, lo abrí con VSCode)
*** con esto hemos redireccionado la salida standard output del comando ls
*** esto mismo se puede aplicar a practicamente cualquier comando dentro de linux

lionel@lionel-ubuntu:~$ ls -l directorio_falso > salida_ls.txt 
ls: cannot access 'directorio_falso': No such file or directory
lionel@lionel-ubuntu:~$ cat salida_ls.txt 
lionel@lionel-ubuntu:~$ 
*** aca vemos que se mostro normalmente el stderr, ya que el operador > aplica solo para el stdout
*** tambien vemos que cuando redirigimos con >, el archivo de destino (si existe) siempre se va a reescribir dese el principio (o se va a crear y empezar a escribir desde el principio si no existe), entonces como ls en este caso no ha generado ningun resultado exitoso (ejecuto el stderr), la operacion de redireccion ha intentado empezar a reescribir el fichero salida_ls.txt, pero como no habia nada que escribir, se ha detenido, y ha provocado que el fichero se truncase (se pierdan los datos anteriores)

lionel@lionel-ubuntu:~$ > nuevofichero.txt
lionel@lionel-ubuntu:~$ cat nuevofichero.txt 
lionel@lionel-ubuntu:~$ ls -l nuevofichero.txt 
-rw-rw-r-- 1 lionel lionel 0 mar  3 17:08 nuevofichero.txt
*** otro ejemplo, con el que vemos que es una forma de crear un ficher vacio (observar que pesa 0 bits)

*** conclusion: el operador > siempre va a truncar el contenido previo del fichero de destino

>>: este operador evita que se trunque el contenido original del archivo de destino vvv

lionel@lionel-ubuntu:~$ ls -lah > salida_ls.txt 
lionel@lionel-ubuntu:~$ tail -n 2 salida_ls.txt 
drwxrwxr-x  4 lionel lionel 4,0K feb 17 17:02 .vscode
-rwxr-xr-x  1 root   root    191 mar  3 02:41 vulnprog.hardlink
lionel@lionel-ubuntu:~$ echo "linea nueva" >> salida_ls.txt 
lionel@lionel-ubuntu:~$ tail -n 2 salida_ls.txt 
-rwxr-xr-x  1 root   root    191 mar  3 02:41 vulnprog.hardlink
linea nueva
*** como vemos, con >> la linea nueva se agrego al final del contenido previo del fichero de destino, sin truncarlo

--------------------

VIDEO 41 - Standard Error (stderr) Redirection

- los operadores > y >> solo sirven para stdoutput 

- entonces, como no existen operadores especiales para redireccionar el stderr, vamos a hacerlo utilizando una estructura dentro del sistema de ficheros que es muy importante, y que utiliza el kernel de linux para poder gestionar adecuadamente los ficheros abiertos, que se denomina FILE DESCRIPTOR

File Descriptor (descriptor de ficheros):  

- file descriptor es algo que tiene sentido cuando se abre un fichero
- cuando un proceso cualquiera abre un fichero, es decir, realiza una peticion al kernel para que se abra un fichero (para empezar a leerlo, para empezar a escribirlo, etc) el kernel lo que va a hacer es retornarle (al proceso) un descriptor de fichero, que es un numerito que va a identificar a ese fichero que se esta abriendo.
- el descriptor de fichero, al mismo tiempo, va a apuntar a una tabla que se llama GLOBAL FILE TABLE, es decir, una tabla de ficheros global que maneja el kernel,y que va a tener ciertas cosas importantes, como por ejemplo:
* informacion sobre el inodo del fichero que se ha abierto 
* las restricciones de acceso a ese fichero 
- con lo cual, cuando tu quieras consumirlo, dependiendo del descriptor que tengas y dependiendo de lo que aparezca en esa tabla global de ficheros, el kernel te va a dejar realizar unas acciones sobre ese fichero que esta abierto u otras acciones diferentes.

- entonces, como vimos, el stdout, el stderr y el stdinput (soft links) apuntan en ultima instancia al mismo fichero especial /dev/pts/0, pero lo que cambia entre ellos es el file descriptor 
* el stdoutput tiene un file descriptor asociado
* el stderr tiene un file descriptor asociado
* el stdinput tiene un file descriptor asociado
- que apuntan a esta entrada en la global file table donde tendran una serie de restricciones de acceso y donde se indica que uno sirve para redireccionar salida, otro sirve para redireccionar error y otro sirve para redireccionar entrada

- lo interesante es que sepamos cual es el file descriptor de un fichero vvv

lionel@lionel-ubuntu:~$ ls -l /dev/stdout 
lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdout -> /proc/self/fd/1
*** podemos ver en este ficherito (/proc/self/fd) al que esta apuntando el enlace simbolico /dev/stdout que el file descriptor es el 1

lionel@lionel-ubuntu:~$ \
ls -l /dev/stdout;\
ls -l /dev/stderr;\
ls -l /dev/stdin;
lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdout -> /proc/self/fd/1
lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stderr -> /proc/self/fd/2
lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdin -> /proc/self/fd/0
*** file descriptor stdin = 0
*** file descriptor stdout = 1
*** file descriptor stderr = 2

lionel@lionel-ubuntu:~$ ls -l /dev/stdin; ls -l /dev/stdout; ls -l /dev/stderr 
lrwxrwxrwx 1 root root 15 mar 16 15:16 /dev/stdin -> /proc/self/fd/0
lrwxrwxrwx 1 root root 15 mar 16 15:16 /dev/stdout -> /proc/self/fd/1
lrwxrwxrwx 1 root root 15 mar 16 15:16 /dev/stderr -> /proc/self/fd/2

*** como vemos, la informacion del file descriptor de cada uno de estos ficheros se encuentra en el directorio /proc, que como vimos consiste en un sistema de ficheros virtual que se va a creando con todos los procesos que tenemos arrancados en ese momento

*** entonces probablemente, si queremos saber el file descriptor de cualquier otro archivo que esta abierto en un momento determinado tendremos que ir a buscarlo dentro de "/proc/" + el PID de ese proceso (veremos mas adelante el tema de los PID)  + "/" , y dentro de ese proceso que esta en ejecucion tendra abierto un fichero, y como lo tiene abierto tendra un file descriptor asociado

REPASO DEL DIRECTORIO /proc vvv

*** este directorio esta administrado por el sistema, no debemos tocar nada de lo que hay dentro
*** si tiramos un ls en /proc vamos a obtener una interfaz con el Kernel
*** aqui vamos a obtener un monton de informacion sobre como esta funcionando el Kernel y los dispositivos hardware que tenemos en nuestra maquina
*** tenemos por ejemplo ficheros como filesystems que nos da informacion sobre los sistemas de ficheros que tenemos cargados 
*** meminfo de informacion sobre la memoria
*** tenemos varios ficheros que nos van a dar informacion sobre el hardware y el funcionamiento del kernel
*** tenemos tambien cpuinfo sobre la cpu 
*** tenemos tambien directorios con diferentes numeros 
*** estos numeros son PIDs, pero basicamente son identificadores de procesos 
*** cada uno de los procesos que tenemos tiene un directorio asociado dentro de /proc que contiene informacion sobre el estado en el que se encuentra en este momento, como se ha ejecutado, etc.
*** lo que vemos dentro de /proc no es un sistema de ficheros propiamente dicho sino que se suele llamar sistema de ficheros virtual porque esta como creado sobre la marcha, en tiempo de ejecucion 

*** si hacemos un ls -la /proc comprobamos que la mayoria de los los archivos y directorios continenen 0 bits

lionel@lionel-ubuntu:/proc$ echo $$
2360
*** esto me da el PID del proceso actual, que seria la propia shell, que es un proceso dentro de nuestro SO

lionel@lionel-ubuntu:/proc$ cd 2360
*** entro al directorio del proceso

lionel@lionel-ubuntu:/proc/2360$ ls -la .
*** comprobamos que todos los archivos que figuran dentro tienen 0 bits 

*** por eso es que se llama a lo que hay dentro de /proc un sistema de ficheros virtual, no es propiamente un sistema de ficheros

lionel@lionel-ubuntu:/proc/2360$ less status
*** con este comando podemos ver el estado de nuestro proceso (del 2360, status es un fichero dentro de /proc/2360)

Ahora veremos como redirigir el stderr haciendo uso de este file descriptor vvv 

lionel@lionel-ubuntu:~$ ls -la /dev/stderr 
lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stderr -> /proc/self/fd/2
*** file descriptor stderr = 2

lionel@lionel-ubuntu:~$ ls -l directorio_inexistente 2> error_ls.txt
*** redirijo el posible error
*** le estoy indicando que en caso de error, lo que deberia ir al standard error (file descriptor 2), lo redirija a error_ls.txt

lionel@lionel-ubuntu:~$ cat error_ls.txt 
ls: cannot access 'directorio_inexistente': No such file or directory
lionel@lionel-ubuntu:~$ code error_ls.txt 
*** compruebo que el error se redirecciono correctamente a donde queria (luego lo abro en VSCode)

- Forma de redirigir el stdout o el stderr indistintamente al mismo fichero destino vvv
---------------------------------------------------------------------------------------

lionel@lionel-ubuntu:~$ \
ls -l dir1/ >> ls-salida.txt 2>&1;\
ls -l dir19/ >> ls-salida.txt 2>&1;\
ls -l dir2/ >> ls-salida.txt 2>&1;\
ls -l dir29/ >> ls-salida.txt 2>&1;\
cat ls-salida.txt 
total 0
-rw-rw-r-- 1 lionel lionel 0 mar  3 20:38 ficheroA.txt
-rw-rw-r-- 1 lionel lionel 0 mar  3 20:39 ficheroB.txt
ls: cannot access 'dir19/': No such file or directory
total 0
-rw-rw-r-- 1 lionel lionel 0 mar  3 20:41 ficheroQ.txt
-rw-rw-r-- 1 lionel lionel 0 mar  3 20:41 ficheroR.txt
ls: cannot access 'dir29/': No such file or directory

*** con el operador "2>&1" estoy indicando que, en caso de error, este se redirija al mismo fichero destino previo a dicho operador
*** lo que estamos indicando con este operador es que queremos que redirija el descriptor 2 (el stderr) al file descriptor 1 (stdoutput)
*** entonces lo que realmente esta pasando es que el stderr se redirije al stdoutput, y el stdoutput lo redirijimos a ls-salida.txt, con lo que el stdoutput como el stderr se redirigen al mismo fichero destino

*** en versiones modernas de la shell contamos con el operador &> (o &>>) que de manera mas sencilla nos permite redirigir tanto el stdoutput como el stderr al mismo fichero de destino vvv 

lionel@lionel-ubuntu:~$ \
ls -l dir1/ &>> ls-salida.txt;\
ls -l dir19/ &>> ls-salida.txt;\
ls -l dir2/ &>> ls-salida.txt;\
ls -l dir29/ &>> ls-salida.txt

--------------------

42. /dev/null

lionel@lionel-ubuntu:~$ \ 
ls -lah /dev/null;\
ls -lah /dev/pts/0;
 : command not found
crw-rw-rw- 1 root root 1, 3 mar  3 12:15 /dev/null
crw--w---- 1 lionel tty 136, 0 mar  3 21:22 /dev/pts/0
*** lo primero que vemos es que antes de los permisos viene referenciado con una "c", que indica que se trata de un CARACTER DEVICE FILE, o sea, un fichero similar al que apuntaban los soft link stdin, ...out y ...err, es decir, el fichero especial /dev/pts/0
*** entonces /dev/null es un CARACTER DEVICE FILE

- /dev/null se diferencia de /dev/pts/0 en que toda la informacion que redirijamos a /dev/null se va a eliminar
- /dev/null es como si fuese una papelera donde todo lo que nosostros mandemos se borra por completo (no se almacena en ninguna parte) y por supuesto, no se va a poder recuperar 

lionel@lionel-ubuntu:~$ find /var/log/ -name auth.log
/var/log/auth.log
find: ‘/var/log/private’: Permission denied
find: ‘/var/log/gdm3’: Permission denied
find: ‘/var/log/speech-dispatcher’: Permission denied
*** busco dentro de /var/log ficheros que se llamen auth.log
*** como se ve, se muestra tanto el stdoutput como el stderr 

lionel@lionel-ubuntu:~$ find /var/log/ -name auth.log 2> stderr.txt
/var/log/auth.log
*** forma de redirigir el stderr al fichero stderr.txt y mostrar solo el stdoutput

ionel@lionel-ubuntu:~$ find /var/log/ -name auth.log 2> /dev/null 
/var/log/auth.log
*** de esta forma redirigimos el stderr a /dev/null para no estar creando archivos que ocupen espacio ya que en este caso es informacion que no nos interesa
*** recordar que lo que mandamos a este fichero especial (CARACTER DEVICE FILE) no se puede recuperar

--------------------

43. Standard Input (stdin) Redirection

- para empezar a hablar del stdin es importante volver a la utilidad cat 

lionel@lionel-ubuntu:~$ \
echo "fichero1" > fichero1;\
echo "fichero2" > fichero2;\
echo "fichero3" > fichero3

lionel@lionel-ubuntu:~$ cat fichero1 fichero2 fichero3 > fichero_total
lionel@lionel-ubuntu:~$ cat fichero_total 
fichero1
fichero2
fichero3

lionel@lionel-ubuntu:~$ cat fichero* > fichero_total2
lionel@lionel-ubuntu:~$ cat fichero_total2
fichero1
contenido de fichero1.txt
fichero2
contenido fichero2.txt
fichero3
contenido fichero4.txt
fichero1
fichero2
fichero3

lionel@lionel-ubuntu:~$ cat
*** si ejecutamos la utilidad cat sin pasarle ningun argumento, esta se queda esperando recibir informacion del stdin, y el stdin esta asociado a nuestro teclado vvv

lionel@lionel-ubuntu:~$ cat
esto es un texto de pruebas
esto es un texto de pruebas
esto es otro texto de pruebas
esto es otro texto de pruebas
*** observar que ingrasamos cualquier string, y cuando damos ENTER, cat redirige el stdin al stdoutput (comportamiento por default de la utilidad)
*** Ctrl + d para indicarle a cat que hemos llegado al final del fichero, entonces cat se cierra
*** entonces cat esta recibiendo en este caso el texto del standard input (que esta asociado por defecto a nuestro teclado) y luego lo redirige al standard output

- podemos aprovechar este comportamiento para por ejemplo, escribir un archivo en linea vvv

lionel@lionel-ubuntu:~$ > video43
lionel@lionel-ubuntu:~$ code video43 
lionel@lionel-ubuntu:~$ cat > video43 
linea 1 texto introducido por stdin
linea 2 texto introducido por stdin

linea 3 texto introducido por stdin luego de un salto de linea
lionel@lionel-ubuntu:~$ cat video43 
linea 1 texto introducido por stdin
linea 2 texto introducido por stdin

linea 3 texto introducido por stdin luego de un salto de linea
lionel@lionel-ubuntu:~$ 

operador de redireccion de stdin == < 
-------------------------------------

lionel@lionel-ubuntu:~$ cat < video43 
linea 1 texto introducido por stdin
linea 2 texto introducido por stdin

linea 3 texto introducido por stdin luego de un salto de linea
lionel@lionel-ubuntu:~$ 
*** con esto le estoy mandando a cat como entrada el contenido de video43 (sustituyendo lo que viene por defecto en stdin que es el teclado) y cat lo reenvia automaticamente al stdout y por eso nos sale por pantalla

*** este es el concepto de redireccion de stdin 
*** con cat no tiene demasiado sentido, pero es para entender como cambiariamos el comportamiento de recibir esa entrada por stdin o por teclado 
*** como veremos mas adelante, esto tiene bastante utilidad, para ciertos comandos, ciertas herramientas, que reciben cierta informacion y que a mano por teclado tardariamos muchisimo con lo cual metiendola automaticamente desde un fichero, va a ser muchisimo mas optimo

--------------------

44. Pipelines

| == operador tuberia (pipeline)
* nos va a permitir concatenar comandos dentro de la shell de manera que el stdoutput de un comando sirva de stdin del siguente comando vvv

lionel@lionel-ubuntu:~$ ls -l /usr/bin | less
*** el stdtoutput de ls -l  se esta redirigiendo al stdin de less
*** tab "q" para cerrar

--------------------

45. Filtros y búsquedas: sort, uniq, wc

45.1) comando sort
* va a servir para ordenar las lineas de un fichero

lionel@lionel-ubuntu:~$ man sort
*** para acceder al manual de sort 

- por default, ordenara las lineas del fichero por orden alfabetico 

- podemos combinar este comando con los pipelines (tuberias) de la seccion anterior

lionel@lionel-ubuntu:~$ ls /bin /usr/bin | sort | less

45.2) comando uniq
lionel@lionel-ubuntu:~$ man uniq
*** manual uniq 

lionel@lionel-ubuntu:~$ ls /bin /usr/bin | sort | uniq | less

lionel@lionel-ubuntu:~$ ls /bin /usr/bin | sort | uniq -d | less
*** obtengo los directorios o ficheros duplicados y irdenados alfabeticamente

45.3) comando wc
lionel@lionel-ubuntu:~$ man wc
*** manual wc 

- wc nos va a permitir contar lineas, palabras y bits de un fichero

lionel@lionel-ubuntu:~$ wc /var/log/auth.log 
  241  3062 27303 /var/log/auth.log
*** 241 = numero de lineas del fichero
*** 3062 = numero de palabras
*** 27303 = numero de bytes

lionel@lionel-ubuntu:~$ wc /var/log/auth.log -l
241 /var/log/auth.log
lionel@lionel-ubuntu:~$ wc /var/log/auth.log -w
3062 /var/log/auth.log
lionel@lionel-ubuntu:~$ wc /var/log/auth.log -c
27303 /var/log/auth.log
lionel@lionel-ubuntu:~$ 
*** se pueden obtener estos valores por separado

--------------------

46. Filtros y búsquedas (Parte II): grep, head, tail, tee

46.1) grep 

lionel@lionel-ubuntu:~$ man grep
*** manual comando grep

lionel@lionel-ubuntu:~$ grep lionel /var/log/auth.log
*** retorna todas las lineas del fichero especificado, que contengan el patron pasado como argunmento 

lionel@lionel-ubuntu:~$ grep -i lionel /var/log/auth.log
*** realiza la busqueda ignorando mayusculas y minusculas

lionel@lionel-ubuntu:~$ grep -v lionel /var/log/auth.log
*** retorna todas las lineas del fichero especificado, que NO contengan el patron pasado como argunmento

lionel@lionel-ubuntu:~$ ls /usr/bin/ | sort | grep zip
*** busco ficheros en /usr/bin, que contengan el patron "zip", y quiero verlos ordenados alfabeticamente

46.2) head 

lionel@lionel-ubuntu:~$ head /var/log/auth.log
*** head saca por default por el stdoutput las primeras 10 lineas del fichero 

lionel@lionel-ubuntu:~$ head /var/log/auth.log -n 5
*** podemos indicar la cantidad de lineas que queremos ver 

46.3) tail

lionel@lionel-ubuntu:~$ tail /var/log/auth.log
*** tail saca por default por el stdoutput las ultimas 10 lineas del fichero 

lionel@lionel-ubuntu:~$ tail /var/log/auth.log -n 5
*** podemos indicar la cantidad de lineas que queremos ver 

lionel@lionel-ubuntu:~$ ls /usr/bin/ | head -n 5
*** saco los primeros 5 ficheros o directorios que contiene /usr/bin

46.4) cuando estamos monitorizando ficheros de log (muchas veces nos va a tocar hacer esto cuando algun programa este dando un error o por lo que sea), podemos usar el comando tail con -f para abrir por ejemplo un fichero de log y ver en tiempo real lo que se va escribiendo en el vvv

lionel@lionel-ubuntu:~$ tail -f /var/log/auth.log
*** Ctrl + c para detener la ejecucion y volver a la terminal 

46.5) tee 

lionel@lionel-ubuntu:~$ ls /usr/bin/ | sort | tee fichero_sort.txt | uniq | grep cat
*** tee me sirve para hacer debbuging
*** en este ejemplo, captura el stdout del comando sort, crea el fichero fichero_sort.txt guardando en él el stdout de sort, sin interrumpir la ejecucion del comando uniq, ni luego, del comando grep 
*** entonces sirve para, si me doy cuenta que esta secuencia de comandos esta fallando en alguna parte, capturando los stdoutputs intermedios puedo ir debugueando e identificar donde esta el error

--------------------

46. Tarea 

Completa las siguientes actividades utilizando las herramientas de filtrado y búsqueda de información que se han presentado en los temas anteriores.

Preguntas de esta tarea

1. Muestra por pantalla todos los archivos y directorios que tienes en tu directorio de trabajo ordenados por tamaño.
lionel@lionel-ubuntu:~$ ls -lS 
*** ordenados por peso de mayor a menor

lionel@lionel-ubuntu:~$ ls -lSr
*** ordenados por peso de nmenor a mayor

2. Crea un nuevo fichero en tu sistema Linux ejecutando el siguiente comando:

echo -e "rojo,1,coche,madrid\nazul,4,moto,mexico\namarillo,2,bicicleta,paris\nverde,6,avion,roma" > fichero.csv

Ordena el fichero que acabas de crear (fichero.csv) por el segundo campo teniendo en cuenta que los campos están separados por el delimitador ,

lionel@lionel-ubuntu:~$ sort -t "," -k2 -n fichero.csv
*** -t"," indica que quiero separar las lineas por ","
*** -k2 que la clasificacion debe hacerse segun el 2do campo 
*** -n indica que se debe realizar una ordenacion numerica (por el segundo campo)

3. Muestra por pantalla la línea 55 del fichero auth.log que se encuentra en /var/log
lionel@lionel-ubuntu:~$ sed -n 55p /var/log/auth.log
Mar  3 02:46:53 lionel-ubuntu sudo:   lionel : TTY=pts/0 ; PWD=/home/lionel ; USER=root ; COMMAND=/usr/bin/ln /usr/bin/vulnprog vulnprog.hardlink
*** sed es un editor de flujo utilizado comúnmente para manipular y transformar textos.
*** -n: esta opción indica a sed que solo debe imprimir las líneas que se le indiquen explícitamente.
*** 55p: este comando le dice a sed que imprima la línea 55

SOLUCION PROFESOR:

1. Muestra por pantalla todos los archivos y directorios que tienes en tu directorio de trabajo ordenados por tamaño.
lionel@lionel-ubuntu:~$ ls -l ~ | sort -h -k5
*** La opción -h de sort compara números legibles para el ser humano (por ejemplo, 2K 1G)
*** La opción -k5 indica a sort que utilice el quinto campo de la salida del comando ls para ordenar, en este caso, el campo tamaño:
*** drwxr-xr-x 2 santi santi <<<4096>>> oct  5 11:36 Desktop

2. Ordena el fichero que acabas de crear (fichero.csv) por el segundo campo teniendo en cuenta que los campos están separados por el delimitador ,
lionel@lionel-ubuntu:~$ sort -t ',' -nk2 fichero.csv
*** La opción -t permite indicar un separador que sort interpretará para cada una de las líneas del fichero.
*** La opción -nk2 indica a sort que trate los valores como numéricos (-n) y que los ordene por el segundo campo (-k2).

3. Muestra por pantalla la línea 55 del fichero auth.log que se encuentra en /var/log
lionel@lionel-ubuntu:~$ head -n 55 /var/log/auth.log | tail -n 1 

--------------------

47. Extra: Comando sed

sed es otro comando interesante que es posible que os resulte de utilidad en algunas ocasiones. 
Su función principal es reemplazar texto de un fichero. 
Sin embargo, puede combinarse con los comandos que hemos visto en este tema utilizando pipelines para realizar otras muchas tareas.
Os animo a que le echéis un ojo a esta herramienta antes de pasar a la siguiente sección y os planteeis algunos casos de uso como los siguientes.
Reemplazar o sustituir una cadena de texto en un fichero
Reemplazar una cadena de texto en una línea determinada de un fichero
Añadir un carácter al comienzo de cada línea de un fichero
Para el que quiera profundizar sobre el uso de sed, le recomiendo que revise la siguiente referencia: https://www.geeksforgeeks.org/sed-command-in-linux-unix-with-examples/
¡Un saludo y nos vemos en la siguiente sección!

--------------------

49. Permisos y usuarios: passwd, shadow, group

- linux viene de una tradicion similar a unix
- a diferencia de otros sistemas operativos tradicionales como MS-DOS (del que deriva Windows), linux es un SO multitarea que quiere decir que tenemos varios procesos simultaneos (podemos realizar varias tareas de manera simultanea), pero tambien es un SO multiusuario
- esto quiere decir que dentro del propio SO pueden convivir varios usuarios
- esto significa que mas de una persona pueden utilizar el ordenador al mismo tiempo (por ejemplo, si un usuario se conecta al ordenador a traves de la red, desde una sesion remota, vamos a tener varios usuarios trabajando simultaneamente con permisos distintos)
- esta capacidad multiusuario que tiene linux es una caracteristica que esta profundamente integrada dentro del propio SO 

- en el modelo de seguridad que implementa linux, un usuario va a ser propietario tanto de ficheros como de directorios, y cuando un usuario es dueño de un archivo o directorio el usuario va a tener el control completo sobre su acceso

- los usuarios a su vez van a poder pertenecer a grupos, que van a estar formados por uno o mas usuarios y que van a tener una serie de propietarios (de los grupos) que van a ser los que van a permitir el acceso de otros nuevos usuarios a ese mismo grupo, y cuando un usuario se añade a un grupo va a heredar una serie de permisos y privilegios sobre algunos ficheros y directorios del sistema de ficheros

lionel@lionel-ubuntu:~$ id
uid=1000(lionel) gid=1000(lionel) groups=1000(lionel),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),135(lxd),136(sambashare)
*** el comando id nos va a dar nuestra identidad, es decir, el usuario con que estamos ejecutando ahora mismo esta shell
*** uid=1000(lionel) -> user identifier (identificador de usuario), es el que realmente va a utilizar por detras linux para realizar tareas con nuestro usuario (a los humanos nos proporciona un nombre de usuario, en este caso "lionel", porque yo asi lo configure cuando cree la VM, para que sea mas facil de gestionar)
*** gid=1000(lionel) -> group identifier -> grupo "lionel" (identificador == 1000)
*** grupo lionel -> en linux se crea un grupo unico de un solo miembro para cada usuario
*** el resto son otros grupos en el que el usuario "lionel" esta incluido por defecto

- la informacion sobre usuarios se encuentra en el fichero /etc/passwd
- cada entrada (linea) del fichero corresponde auno de los usuarios creados dentro del SO

lionel@lionel-ubuntu:~$ grep lionel /etc/passwd
lionel:x:1000:1000:lionel,,,:/home/lionel:/bin/bash
*** id == user_name:pass:uid:gid:account_name,,,:working_directory:default_shell
*** repaso: grep retorna todas las lineas del fichero especificado, que contengan el patron pasado como argunmento (en este caso, todas las lineas de /etc/passwg que contengan "lionel")

- entrada en /etc/passwd asociada al usuario "lionel" vvv 

lionel:x:1000:1000:lionel,,,:/home/lionel:/bin/bash
* lionel -> nombre del usuario 
* x -> referencia a la contraseña (la contraseña se va almacenar hasheada en el fichero /etc/shadow)
* 1000 -> uid
* 1000 -> gid
* lionel -> nombre real de la cuenta (porque en algunos casos podriamos tener un alias)
* /home/lionel -> directorio raiz de trabajo
* /bin/bash -> la shell que esta asignada por defecto cuando se loguee este usuario (/bin es soft link a /usr/bin, entonces /bin/bash == /user/bin/bash)
*** id == user_name:pass:uid:gid:account_name,,,:working_directory:default_shell

lionel@lionel-ubuntu:~$ less < ls -l /bin
There is no -l option ("less --help" for help)
/bin is a directory
*** quise redirigir la salida standard de ls a less para leer dinamicamente el contenido de /bin (soft link a /usr/bin) y me tiro error ya que less solo lee el contenido de ficheros

lionel@lionel-ubuntu:~$ ls /bin | less
*** la forma correcta de pasar el stdoutput de ls como stdin de less es con un pipeline 
*** /bin es soft link a /usr/bin 

lionel@lionel-ubuntu:~$ cat /etc/shadow
cat: /etc/shadow: Permission denied
*** en este fichero estan las contraseñas de los usuarios
*** un usuario normal y corriente no tiene privilegios para acceder al contenido de este fichero 

lionel@lionel-ubuntu:~$ sudo cat /etc/shadow
*** con sudo elevamos privilegios para el usuario conectado (en este caso lionel) y asi acceder al contenido del fichero

lionel@lionel-ubuntu:~$ sudo grep lionel /etc/shadow
lionel:$y$j9T$LuYWGnrACKizsYbT73ops0$sCk3V3L0E99QGi5SgSw9iDq36ho7T9VbRprLGWEpKl.:19604:0:99999:7:::
*** contraseña hasheada de lionel 
*** este hash se genera con diferentes algoritmos, y se puede llegar a romper con algunas herramientas de cracking y obtener la contraseña real 

lionel@lionel-ubuntu:~$ sort /etc/group | grep lionel
adm:x:4:syslog,lionel
cdrom:x:24:lionel
dip:x:30:lionel
lionel:x:1000:
lpadmin:x:122:lionel
lxd:x:135:lionel
plugdev:x:46:lionel
sambashare:x:136:lionel
sudo:x:27:lionel
*** el usuario lionel esta en todos estos grupos (parte de la info que nos muestra el comando id)
*** group_name:pass:gid:is_user_included

- desglose de una entrada del fichero /etc/group vvv
lionel:x:1000:
lionel: nombre del grupo
x: referencia a la contraseña del grupo (tambien se encuentran el el fichero /etc/shadow)
*** los grupos pueden tener una contraseña
*** generalmente no se implementan 
*** una contraseña serviria para, por ejemplo, que un usuario que no pertenece a un grupo, pueda asumirlos privilegios de este grupo en un momento determinado, si conoce e ingresa esta contraseña 
gid: group identifier
*** group_name:pass:gid:is_user_included

CONCLUSIONES:
file /etc/passwd -> informacion de usuarios
file /etc/shadow -> informacion contraseñas de estos usuarios
file /etc/group  -> informacion de grupos dentro de nuestro SO

- linux es un sistema multitarea y multiusuario 
- los usuarios normalmente van a tener una serie de privilegios para acceder a ficheros y directorios dentro del sistema de ficheros 
- los usuarios pueden pertenecer a grupos, y en el momento que pertenecen a un grupo heredan tambien una serie de privilegios sobre ficheros y directorios de nuestro sistema de ficheros

--------------------

50. Lectura (r), Escritura (w) y Ejecución (x)

- dentro de linux vamos a tener usuarios 
- vamos a tener grupos a los que van a pertenecer estos usuarios 
- y dependiendo del usuario que sea, y del grupo al que pertencezca, el usuario va a tener una serie de permisos de lectura, escritura y ejecucion sobre los ficheros y directorios de nuestro sistema de ficheros

lionel@lionel-ubuntu:~$ ls -ldh Desktop | grep Desktop 
drwxr-xr-x 5 lionel lionel 4,0K feb 24 18:21 Desktop

- desglose con lo que sabemos hasta ahora vvv
drwxr-xr-x cantHardLinks lionel lionel fileSize updatedAt fileOrDirectoryName

- añado desglose de usuario y grupo vvv

drwxr-xr-x cantHardLinks fileOwnerUser fileOwnerGroup fileSize updatedAt fileOrDirectoryName
*** fileOwnerUser -> usuario dueño del fichero, normalmente se va a corresponder con el usuario que lo creo
*** fileOwnerGroup -> grupo dueño del fichero (en este caso el grupo es "lionel", grupo primario del usuario "lionel" - recordar que en linux se crea un grupo unico de un solo miembro para cada usuario del SO -)

- añado desglose de la parte de permisos vvv 
d        rwx             r-x              r-x                5               lionel          lionel          4,0K        feb 24 18:21    Desktop
typeFile userPermissions groupPermissions worldPermissions   cantHardLinks   fileOwnerUser   fileOwnerGroup  fileSize    updatedAt       fileOrDirectoryName
drwxr-xr-x 5 lionel lionel 4,0K feb 24 18:21 Desktop

r = read
w = writ
x = execution

lionel@lionel-ubuntu:~$ find /var/log -maxdepth 1 -name auth.log
/var/log/auth.log
lionel@lionel-ubuntu:~$ file /var/log/auth.log
/var/log/auth.log: ASCII text
*** find busca archivos y directorios en el directorio recibido como primer argumento (en esta caso /var/log) el patron pasado al final (-name auth.log) y retorna su ruta absoluta de lo que encuentre (caso contrario, no retorna nada)
*** en este caso, le pasamos el flag -maxdepth 1 para que busque seolo en el primer nivel del directorio /var/log
*** en este caso, retorna el full path de lo que encontro con el patron recibido, y con file comprobamos que se trata de un fichero de texto

lionel@lionel-ubuntu:~$ find /var/log -name auth.log
/var/log/auth.log
find: ‘/var/log/private’: Permission denied
find: ‘/var/log/gdm3’: Permission denied
find: ‘/var/log/speech-dispatcher’: Permission denied
*** volvemos a realizar la busqueda del mismo patron, pero al quitar el flag -maxdepth 1, estamos indicando que busque en todo el contenido del directorio /var/log 
*** 

lionel@lionel-ubuntu:~$ history | grep "grep" | grep "lionel" | grep "group" | grep "sort"
 1988  grep lionel /etc/group | sort
 1990  sort /etc/group | grep lionel
 1992  sort /etc/group | grep lionel
 1999  sort /etc/group | grep lionel
 2192  history | grep "grep" | grep "lionel" | grep "group" | grep "sort"
*** busco en history el comando que me mostraba en que grupos esta incluido el usuario "lionel", ordenados alfabeticamente

sort /etc/group | grep lionel
ls -ldh /var/log/ /var/log/private/ /var/log/gdm3/ /var/log/speech-dispatcher/
find /var/log -name auth.log

lionel@lionel-ubuntu:~$ sort /etc/group | grep lionel
adm:x:4:syslog,lionel
cdrom:x:24:lionel
dip:x:30:lionel
lionel:x:1000:
lpadmin:x:122:lionel
lxd:x:135:lionel
plugdev:x:46:lionel
sambashare:x:136:lionel
sudo:x:27:lionel
lionel@lionel-ubuntu:~$ ls -ldh /var/log/ /var/log/private/ /var/log/gdm3/ /var/log/speech-dispatcher/
drwxrwxr-x 13 root              syslog 4,0K mar  9 14:00 /var/log/
drwx--x--x  2 root              gdm    4,0K sep  3  2023 /var/log/gdm3/
drwx------  2 root              root   4,0K ago  7  2023 /var/log/private/
drwx------  2 speech-dispatcher root   4,0K may 23  2023 /var/log/speech-dispatcher/
lionel@lionel-ubuntu:~$ find /var/log -name auth.log
/var/log/auth.log
find: ‘/var/log/private’: Permission denied
find: ‘/var/log/gdm3’: Permission denied
find: ‘/var/log/speech-dispatcher’: Permission denied
lionel@lionel-ubuntu:~$ 

--------------------

51. Permisos en directorios

Permisos en directorios
En muchas ocasiones puede resultar confusa la asignación de permisos a directorios. A continuación os dejo un pequeño resumen que podréis recordar fácilmente.

Permisos en directorios:

El permiso de ejecución en los directorios permite acceder a los archivos dentro del directorio.

El permiso de lectura permite enumerar las entradas del directorio.

El permiso de escritura permite crear y eliminar entradas en el directorio.

Tener permiso de lectura o escritura en un directorio sin permiso de ejecución no es útil. 
Tener permiso de ejecución pero no de lectura es ocasionalmente útil: permite acceder a los archivos sólo si se conoce su nombre exacto, un mecanismo muy rudimentario de protección.

En la práctica los permisos útiles sobre un directorio son:

---: sin acceso

--x: puede acceder a los archivos cuyo nombre se conoce

r-x: acceso normal de sólo lectura

rwx: acceso normal de lectura y escritura

--------------------

52. El usuario root

sort /etc/group | grep lionel
*** comando para saber a que grupos pertenece "lionel" o cualquier otro usuario

- el usuario root se denomina superusuario dentro de linux 
- se denomina superusuario porque va a tener privilegios para realizar practicamente cualquier accion dentro de nuestro sistema linux

- cuando utilizemos este usuario vamos a tener capacidad de leer, escribir, ejecutar y modificar todos los ficheros y directorios que hay en el sistema

- practicamente todos los ficheros importantes dentro de linux, todos aquellos que el sistema busca proteger para que no los modifique de forma accidental un usuario 
- es una forma de añadir cierto grado de seguridad a ficheros y directorios que no deben modificarse porque pueden afectar al funcionamiento del SO

*** investigue porque puedo ejecutar como root comandos, y chatGTP me dijo que es porque en el archivo /etc/sudoers la entrada "%sudo	ALL=(ALL:ALL) ALL" habilita a los usuarios del grupo sudo (entre los que esta lionel) a gozar de privilegios de root (superadministrador) vvv

lionel@lionel-ubuntu:~$ head -n 4 /etc/shadow
head: cannot open '/etc/shadow' for reading: Permission denied

lionel@lionel-ubuntu:~$ sudo head -n 4 /etc/shadow
root:!:19604:0:99999:7:::
daemon:*:19576:0:99999:7:::
bin:*:19576:0:99999:7:::
sys:*:19576:0:99999:7:::

lionel@lionel-ubuntu:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1465 sep  3  2023 /etc/shadow

lionel@lionel-ubuntu:~$ sort /etc/group | grep lionel
adm:x:4:syslog,lionel
cdrom:x:24:lionel
dip:x:30:lionel
lionel:x:1000:
lpadmin:x:122:lionel
lxd:x:135:lionel
plugdev:x:46:lionel
sambashare:x:136:lionel
sudo:x:27:lionel

lionel@lionel-ubuntu:~$ cat /etc/sudoers | grep "%sudo  ALL=(ALL:ALL) ALL"
cat: /etc/sudoers: Permission denied

lionel@lionel-ubuntu:~$ sudo cat /etc/sudoers | grep "%sudo     ALL=(ALL:ALL) ALL"
%sudo	ALL=(ALL:ALL) ALL

--------------------

53. Modificación de permisos en octal

- para poder modificar los permisos de un fichero o directorio dentro de linux vamos a necesitar ser los propietarios de ese fichero o directorio, o ser el usuario root

Base 10 vvv

 00  01  02  03  04  05  06  07  08  09 
 10  11  12  13  14  15  16  17  18  19 
 20  21  22  23  24  25  26  27  28  29 
 ...
 90  91  92  93  94  95  96  97  98  99 
100 101 102 103 104 105 106 107 108 109
110 111 112 113 114 115 116 117 118 119 

Base 8 (octal) vvv 
 
  00  01  02  03  04  05  06  07
  10  11  12  13  14  15  16  17
  20  21  22  23  24  25  26  27
  ...
  70  71  72  73  74  75  76  77
 100 101 102 103 104 105 106 107
 110 111 112 113 114 115 116 117

lionel@lionel-ubuntu:~$ ls -la fichero.csv 
-rw-rw-r-- 1 lionel lionel 85 mar  5 03:07 fichero.csv
*** nuestro va a entender binario, y va a representar estos permisos (rw-rw-r--)
*** representacion en binario de fichero.csv vvv
r w - r w - r - -
1 1 0 1 1 0 1 0 0

permisos owner = 110 o 6  
permisos group = 110 o 6
permisos world = 100 o 4 
permisos fichero.csv en octal -> 664

lionel@lionel-ubuntu:~$ echo "contenido de ficheroVideo53.txt" > ficheroVideo53.txt

lionel@lionel-ubuntu:~$ file ficheroVideo53.txt 
ficheroVideo53.txt: ASCII text

lionel@lionel-ubuntu:~$ ls -l ficheroVideo53.txt 
-rw-rw-r-- 1 lionel lionel 32 mar  9 23:30 ficheroVideo53.txt
*** permisos por default = 664 

lionel@lionel-ubuntu:~$ cat ficheroVideo53.txt 
contenido de ficheroVideo53.txt

lionel@lionel-ubuntu:~$ chmod 237 ficheroVideo53.txt 
*** 2 == 010 == -w-
*** 3 == 011 == -wx
*** 7 == 111 == rwx

lionel@lionel-ubuntu:~$ ls -l ficheroVideo53.txt 
--w--wxrwx 1 lionel lionel 32 mar  9 23:30 ficheroVideo53.txt

-----------------------------------------------------------------------------------------

*** modificando los permisos de /etc/shadow como root (superadministrador) vvv 

lionel@lionel-ubuntu:~$ ls -l /etc/shadow 
-rw-r----- 1 root shadow 1465 sep  3  2023 /etc/shadow
*** 640

lionel@lionel-ubuntu:~$ chmod 777 /etc/shadow
chmod: changing permissions of '/etc/shadow': Operation not permitted

lionel@lionel-ubuntu:~$ sudo chmod 777 /etc/shadow
[sudo] password for lionel: [password]

lionel@lionel-ubuntu:~$ ls -l /etc/shadow 
-rwxrwxrwx 1 root shadow 1465 sep  3  2023 /etc/shadow
*** 777

lionel@lionel-ubuntu:~$ sudo chmod 640 /etc/shadow
*** 640

lionel@lionel-ubuntu:~$ ls -l /etc/shadow 
-rw-r----- 1 root shadow 1465 sep  3  2023 /etc/shadow

--------------------

54. Modificación de permisos simbólica

u (owner)
g (group)
o (others -> world)
a (all)

lionel@lionel-ubuntu:~$ ls -l ficheroVideo53.txt 
--w--wxrwx 1 lionel lionel 32 mar  9 23:30 ficheroVideo53.txt
*** 237

- le restauro los permisos por default (rw-rw-r-- == 664) vvv

lionel@lionel-ubuntu:~$ chmod a=r ficheroVideo53.txt 
*** a todos (all) solo permisos de lectura

lionel@lionel-ubuntu:~$ ls -l ficheroVideo53.txt 
-r--r--r-- 1 lionel lionel 32 mar  9 23:30 ficheroVideo53.txt

lionel@lionel-ubuntu:~$ chmod u+w,g+w ficheroVideo53.txt 

lionel@lionel-ubuntu:~$ ls -l ficheroVideo53.txt 
-rw-rw-r-- 1 lionel lionel 32 mar  9 23:30 ficheroVideo53.txt

lionel@lionel-ubuntu:~$ chmod o-r,o+x ficheroVideo53.txt 
*** a world le quito permisos de lectura y le agrego permisos de ejecucion

lionel@lionel-ubuntu:~$ ls -l ficheroVideo53.txt 
-rw-rw---x 1 lionel lionel 32 mar  9 23:30 ficheroVideo53.txt

lionel@lionel-ubuntu:~$ chmod a-rwx ficheroVideo53.txt 
*** le quito todos los permisos 

lionel@lionel-ubuntu:~$ ls -l ficheroVideo53.txt 
---------- 1 lionel lionel 32 mar  9 23:30 ficheroVideo53.txt

lionel@lionel-ubuntu:~$ chmod u=rw,g=rw,o=r ficheroVideo53.txt 
*** restauro los permisos por default

lionel@lionel-ubuntu:~$ ls -l ficheroVideo53.txt 
-rw-rw-r-- 1 lionel lionel 32 mar  9 23:30 ficheroVideo53.txt

--------------------

55. Permisos por defecto: umask

- los sistemas linux (como por ejemplo la dsitro ubuntu) crean los ficheros con los siguientes permisos por default vvv 
rw-rw-rw- (666)
- los sistemas linux (como por ejemplo la dsitro ubuntu) crean los directorios con los siguientes permisos por default vvv 
rwxrwxrwx (777)

lionel@lionel-ubuntu:~$ ls -ld directorioVideo55/; ls -l ficheroVideo55.txt 
drwxrwxr-x 2 lionel lionel 4096 mar 10 01:13 directorioVideo55/
-rw-rw-r-- 1 lionel lionel 29 mar 10 01:11 ficheroVideo55.txt
*** cree un directorio y un fichero de prueba 
*** como se ve, los permisos del fichero no coincide con lo que esperamos de ubuntu (falta el permiso w para wl world)
*** esto sucede por como esta seteada nuestra mascara vvv

lionel@lionel-ubuntu:~$ umask
0002
*** observamos la mascara que tenemos activa en este momento, que va a servir para establecer y modificar los permisos por default cuando creamos nuevos ficheros y/o directorios
*** la mascara es una representacion en octal de los permisos

- representacion binaria del seteo actual de la mascara vvv 

000 000 000 010
- por ahora, desestimamos el grupo de la izuqierda 
- el segundo grupo hace referencia a los permisos de usuario sobre un fichero o directorio que se crea
- el tercer grupo hace referencia a los permisos de grupo sobre un fichero o directorio que se crea
- el cuarto grupo hace referencia a los permisos de world sobre un fichero o directorio que se crea

- Funciona asi:
- donde aparezca un 1 en la mascara, ubuntu va a modificar el permiso que se espera por defecto (rw-rw-rw-)
- por eso, en el caso de ficheroVideo55.txt vemos que sus permisos por default son rw-rw-r-- (en vez de rw-rw-rw-)
- por eso, en el caso de directorioVideo55/ vemos que sus permisos por default son drwxrwxr-x (en vez de rwxrwxrwx)

lionel@lionel-ubuntu:~$ umask 
*** modifico la mascara para que no modifique los permisos por defecto cuando se crea un nuevo fichero o directorio

lionel@lionel-ubuntu:~$ ls -ld directorioVideo55/; ls -l ficheroVideo55.txt 
drwxrwxrwx 2 lionel lionel 4096 mar 10 01:26 directorioVideo55/
-rw-rw-rw- 1 lionel lionel 29 mar 10 01:26 ficheroVideo55.txt
*** eliminé y volví a crear el directorio y fichero de pruebas, y ahora vemos como si se crearon con los permisos por defecto de linux

-----------------------------------

- Ejercicio: quitarle por defecto permisos absolutos a world para la creacion de archivos y directorios vvv 

lionel@lionel-ubuntu:~$ umask 0006
*** 000 000 000 110

lionel@lionel-ubuntu:~$ umask
0006

lionel@lionel-ubuntu:~$ > ficheroVideo55_2
lionel@lionel-ubuntu:~$ ls -l ficheroVideo55_2
-rw-rw---- 1 lionel lionel 0 mar 10 01:34 ficheroVideo55_2

lionel@lionel-ubuntu:~$ mkdir directorioVideo55_2
lionel@lionel-ubuntu:~$ ls -ld directorioVideo55_2
drwxrwx--x 2 lionel lionel 4096 mar 10 01:36 directorioVideo55_2
*** vemos que la nueva mascara afecto a los permisos por defecto de un nuevo directorio

--------------------

56. Setuid, Setgid, Sticky bit

lionel@lionel-ubuntu:~$ sudo chmod 777 ficheroVideo56.txt 
*** hasta aca hemos visto que esta es una de las formas de setear los permisos de un fichero 
*** la realidad, es que podemos añadir delante de estos 3 digitos un digito extra que va a permitirnos establecer una serie de permisos especiales que vamos a llamar setuid, setgid y sticky bit vvv

56.1) permiso especial setuid

- este bit, este permiso especial que podemos ponerle a un fichero (concretamente se van a poner en ejecutables) lo que nos va a permitir es cambiar el uid del usuario efectivo (y consideramos usuario efectivo el que este ejecutando ese binario, el que este ejecutando ese fichero) por el uid del usuario propietario

- es decir, si un fichero ejecutable tiene permiso setuid (4xxx), cualquier usuario del sistema va a poder ejecutar ese ejecutable, y en el momento en el que lo ejecute va a convertir su uid en el uid del usuario propietario, y por ende, la ejecucion se hara con los privilegios y en nombre del dueño del ejecutable.

- el valor binario del setuid es 100, es decir, 4 en octal

- establezco el setuid para ficheroVideo56.txt vvv

*** primero que nada, tiene sentido establecer el setuid en un fichero que sea un ejecutable, es decir, en un fichero que tenga codigo a ejecutar, por que es para lo que sirve el setuid, para ejecutar algo en nombre de otro.

lionel@lionel-ubuntu:~$ chmod 4770 ficheroVideo56.txt 
*** establecemos en 4 el setuid de ficheroVideo56.txt, luego damos plenos permisos a usuario y grupo, y ningun permiso para el resto 

lionel@lionel-ubuntu:~$ ls -la ficheroVideo56.txt 
-rwsrwx--- 1 lionel lionel 0 mar 10 01:45 ficheroVideo56.txt // (no se ve, pero el nombre del fichero tiene un background rojo)
*** lo primero que vemos es que la shell le aplico un background rojo al nombre del fichero indicando que este tiene el bit setuid (esto por que este permiso es muy delicado en cuanto a temas de seguridad)
*** tambien vemos que el permiso de ejecucion del usuario esta representado por una s en lugar de una x 
*** esta s quiere decir que el fichero tiene permiso especial setuid, esto quiere decir que cada vez que algun usuario ejecute este fichero ejecutable va a adquirir el identificador del owner (en este caso, el uid de lionel, o sea 1000)

----------------------------------- 

56.2) permiso especial setgid

- si setuid nos permitia ejecutar un binario en nombre del usuario propietario, lo que nos va a permitir hacer setgid es ejecutar un binario esta vez como si perteneciesemos al grupo propietario 

- el valor binario del setgid es 010, es decir, 2 en octal

- establezco el setgid para ficheroVideo56.txt vvv

lionel@lionel-ubuntu:~$ chmod 2770 ficheroVideo56.txt 

lionel@lionel-ubuntu:~$ ls -la ficheroVideo56.txt // (no se ve, pero el nombre del fichero tiene un background amarillo)
-rwxrws--- 1 lionel lionel 0 mar 10 01:45 ficheroVideo56.txt
*** lo primero que vemos es que la shell le aplico un background amarillo al nombre del fichero indicando que este tiene el bit setgid (esto por que este permiso es muy delicado en cuanto a temas de seguridad)
*** tambien vemos que el permiso de ejecucion del grupo esta representado por una s en lugar de una x 
*** esta s quiere decir que el fichero tiene permiso especial setgid
*** si yo ejecuto con cualquier otro usuario este fichero lo que va a ocurrir es que esa ejecucion se va a hacer como si ese usuario perteneciera al grupo propietario del fichero, con lo cual va a tener permisos para realizar ciertas acciones

----------------------------------- 

56.3) permiso especial sticky bit 

- sticky bit proviene de versiones antiguas de linux y de la tradicion de unix donde nosotros podiamos establecer este bit a un fichero o este permiso a un fichero para que no hiciese tanto swaping, para que no fuese tan swapeable
- hoy ya no tiene tanto sentido, de hecho, en versiones modernas de linux (como por ejemplo ubuntu), cuando nosotros establecemos este permiso en ficheros, lo que va a hacer el SO es ignorar el permiso en el fichero y donde si tiene sentido es en directorios
- hoy en dia donde se establece este permiso es unicamente en directorios y es lo que tiene en cuenta pues por ejemplo ubuntu 

- cuando establecemos este permiso en un directorio, lo que va a ocurrir es que los ficheros que se encuentran dentro de ese directorio (los subdirectorios) se van a tratar de una forma especial, de modo que solo los propietarios de esos archivos, el propietario del directorio o el usuario root van a poder renombrar o eliminar los archivos vvv 

- el valor binario del sticky bit es 001, es decir, 1 en octal

lionel@lionel-ubuntu:~$ mkdir directorioVideo5
lionel@lionel-ubuntu:~$ > directorioVideo56/ficheroNuevo.txt
lionel@lionel-ubuntu:~$ ls -l directorioVideo56/
total 0
-rw-rw-r-- 1 lionel lionel 0 mar 10 02:27 ficheroNuevo.txt

lionel@lionel-ubuntu:~$ ls -lad directorioVideo56/
drwxrwxr-x 2 lionel lionel 4096 mar 10 02:27 directorioVideo56/

lionel@lionel-ubuntu:~$ chmod 1770 directorioVideo56/

lionel@lionel-ubuntu:~$ ls -lad directorioVideo56/
drwxrwx--T 2 lionel lionel 4096 mar 10 02:27 directorioVideo56/ // (no se ve, pero el nombre del directorio tiene un background azul)
*** lo primero que vemos es que la shell le aplico un background azul al nombre del directorio indicando que este tiene el bit sticky bit
*** tambien vemos que el permiso de ejecucion del world esta representado por una T en lugar de - 
*** esta T quiere decir que el directorio tiene permiso especial sticky bit

lionel@lionel-ubuntu:~$ cd directorioVideo56/ 
lionel@lionel-ubuntu:~/directorioVideo56$ ls -la ficheroNuevo.txt 
-rw-rw-r-- 1 lionel lionel 0 mar 10 02:27 ficheroNuevo.txt
*** ficheroNuevo.txt ahora va a tener ciertas caracteristicas especiales, aunque no aparezcan aqui reflejadas, a saber vvv 
*** unicamente el usuario propietario de este fichero, el usuario propietario del directorio directorioVideo56/ o el superusuario (root) van a poder eliminar o renombrar el archivo

lionel@lionel-ubuntu:~$ chmod u+s ficheroVideo56.txt
*** notacion simbolica para agregarle el permiso especial setuid a un fichero
*** con "-" removemos el permiso

lionel@lionel-ubuntu:~$ chmod g+s ficheroVideo56.txt
*** notacion simbolica para agregarle el permiso especial setgid a un fichero
*** con "-" removemos el permiso

lionel@lionel-ubuntu:~$ chmod +t directorioVideo56/
*** notacion simbolica para agregarle el permiso especial setuid a un fichero
*** con "-" removemos el permiso

--------------------

57. Cambio de identidad: su

- Añado un nuevo usuario a nustro sistema Ubuntu vvv 

lionel@lionel-ubuntu:~$ adduser testuser
adduser: Only root may add a user or group to the system.

lionel@lionel-ubuntu:~$ adduser testuser
adduser: Only root may add a user or group to the system.
lionel@lionel-ubuntu:~$ sudo adduser testuser
Adding user `testuser' ...
Adding new group `testuser' (1001) ...
Adding new user `testuser' (1001) with group `testuser' ...
Creating home directory `/home/testuser' ...
Copying files from `/etc/skel' ...
New password: [4321]
BAD PASSWORD: The password is shorter than 8 characters
Retype new password: [4321] 
passwd: password updated successfully
Changing the user information for testuser
Enter the new value, or press ENTER for the default
	Full Name []: testuser
	Room Number []: 
	Work Phone []: 
	Home Phone []: 
	Other []: 
Is the information correct? [Y/n] y
lionel@lionel-ubuntu:~$ 
*** creé el usuario testuser asumiendo la identidad de root vvv

lionel@lionel-ubuntu:~$ tail -n 2 /etc/passwd
lionel:x:1000:1000:lionel,,,:/home/lionel:/bin/bash
testuser:x:1001:1001:testuser,,,:/home/testuser:/bin/bash

lionel@lionel-ubuntu:/home$ sudo tail -n 2 /etc/shadow
lionel:$y$j9T$LuYWGnrACKizsYbT73ops0$sCk3V3L0E99QGi5SgSw9iDq36ho7T9VbRprLGWEpKl.:19604:0:99999:7:::
testuser:$y$j9T$1pAcTyuGFiriT3kExKrTx/$geiILwVz48uDwKyGBdDXjjw4CQ.SNSKgufy8OdSvwq1:19792:0:99999:7:::

lionel@lionel-ubuntu:/home$ sort /etc/group | grep lionel; sort /etc/group | grep testuser 
adm:x:4:syslog,lionel
cdrom:x:24:lionel
dip:x:30:lionel
lionel:x:1000:
lpadmin:x:122:lionel
lxd:x:135:lionel
plugdev:x:46:lionel
sambashare:x:136:lionel
sudo:x:27:lionel
testuser:x:1001:

-------------------------

Existen 3 formas de cambiar de identidad dentro de nuestro SO linux (activar la sesion de un 2do usuario, es decir, estando con la sesion de lionel, activar la sesion de testuser, de root - en caso de que este activo como vamos a hablar despues -, etc)

57.1) podemos cambiar de identidad desde la interfaz grafica de la VM, cerrando sesion de lionel e iniciando sesion con testuser

*** Luego, existen 2 formas de cambiar de identidad utilizando la propia shell vvv

57.2) podemos cambiar de identidad utilizando el comando su

lionel@lionel-ubuntu:~$ man su | head -n 4
SU(1)   User Commands   SU(1)

NAME
       su - run a command with substitute user and group ID
*** segun el manual, con su vamos a poder ejecutar un comando cambiando ul uid y el gid del usuario que lo ejecuta

- el comando su lo vamos a utilizar para iniciar una nueva shell como si fuesemos otro usuario, es decir, obteniendo el uid de otro usuario vvv

lionel@lionel-ubuntu:~$ su testuser
Password: [4321]
testuser@lionel-ubuntu:/home/lionel$ pwd
/home/lionel
testuser@lionel-ubuntu:/home/lionel$ id
uid=1001(testuser) gid=1001(testuser) groups=1001(testuser)
*** seguimos en la misma ventana de la terminal, pero ahora iniciamos una nueva shell con la sesion activa de testuser
*** vemos que se da algo raro: por default la sesion la inicia dentro de /home/lionel (el working directory de lionel) siendo que testuser no tiene permisos de usuario ni de grupo para acceder. Igual comprobé que testuser no puede hacer nada aqui dentro vvv

testuser@lionel-ubuntu:/home/lionel$ ls
ls: cannot open directory '.': Permission denied
testuser@lionel-ubuntu:/home/lionel$ cat fichero.txt
cat: fichero.txt: Permission denied
testuser@lionel-ubuntu:/home/lionel$ 
*** de todas formas, a continuacion veremos como corregir esto vvv

testuser@lionel-ubuntu:/home/lionel$ exit
exit
lionel@lionel-ubuntu:~$ 
*** salimos de la shell con testuser activo y se nos devuelve a la shell anterior con la sesion activa de lionel

- ahora veremos como corregir el problema anterior, y que al cambiar de identidad la nueva shell se inicie en el working directory del nuevo usuario vvv

lionel@lionel-ubuntu:~$ su testuser
Password: 
testuser@lionel-ubuntu:/home/lionel$ pwd
/home/lionel
testuser@lionel-ubuntu:/home/lionel$ exit
exit
lionel@lionel-ubuntu:~$ 
*** problema a resolver (observar que al ejecutar exit y cerrar la sesion de testuser se imprime "exit")

lionel@lionel-ubuntu:~$ su -l testuser
Password: 
testuser@lionel-ubuntu:~$ pwd
/home/testuser
testuser@lionel-ubuntu:~$ exit
logout
lionel@lionel-ubuntu:~$ 
*** problema resuelto (observar que al ejecutar exit y cerrar la sesion de testuser se imprime "logout")
*** este comportamiento lo corregimos agregando el flag -l al comando su 

lionel@lionel-ubuntu:~$ su - testuser
Password: 
testuser@lionel-ubuntu:~$ pwd
/home/testuser
testuser@lionel-ubuntu:~$ exit
logout
lionel@lionel-ubuntu:~$ 
*** problema resuelto (observar que al ejecutar exit y cerrar la sesion de testuser se imprime "logout")
*** en esta otra version del flag quye agregamos al comando su, en realidad se esta ejecutando -l, pero por alguna razon es posible omitir la l y funciona de la misma manera

-------------------------

- con su tambien podemos ejecutar comandos en nombre de otro usuario (por ejemplo, desde la sesion de testuser ejecutar comandos solo disponibles para lionel) vvv  

testuser@lionel-ubuntu:/home$ ls -l
total 8
drwxr-x--- 30 lionel   lionel   4096 mar 10 13:47 lionel
drwxr-x--- 16 testuser testuser 4096 mar 10 13:03 testuser
*** estamos con la sesion activa de testuser, y observamos que el working directory lionel no tiene permiso alguno para el mundo (world)

testuser@lionel-ubuntu:/home$ ls -l lionel
ls: cannot open directory 'lionel': Permission denied
*** efectivamente, el comando ls nos saca un error de acceso denegado

testuser@lionel-ubuntu:/home$ chmod o+r lionel
chmod: changing permissions of 'lionel': Operation not permitted
*** intentamos cambiar los permisos de lectura para el mundo de lionel, para poder leer el directorio con testuser, y el comando chmod nos indica que es una operacion no permitida (porque esta operacion sobre lionel esta restringda a lionel o root)

testuser@lionel-ubuntu:/home$ su -c "chmod o+r lionel" lionel
Password: [1234]
*** de esta forma, ejecutamos en nombre de lionel el comando chmod sobre el wd lionel (propied de lionel) para darle permisos de lectura al mundo, y no vemos ningun error
*** su -c + "comando a ejecutar en nombre del usuario del cual queremos tomar su identidad (todo entre comillas)" nombre_usuario_del_cual_queremos_tomar_su_identidad

testuser@lionel-ubuntu:/home$ ls -l 
total 8
drwxr-xr-- 30 lionel   lionel   4096 mar 10 13:47 lionel
drwxr-x--- 16 testuser testuser 4096 mar 10 13:03 testuser
*** comprobamos que el permiso de lectura para wd lionel se ha aplicado correctamente

testuser@lionel-ubuntu:/home$ ls -l lionel
-????????? ? ? ? ?            ? app.py
d????????? ? ? ? ?            ? Desktop
d????????? ? ? ? ?            ? dir1
d????????? ? ? ? ?            ? dir2
d????????? ? ? ? ?            ? dir3
d????????? ? ? ? ?            ? dir4
d????????? ? ? ? ?            ? dir5
d????????? ? ? ? ?            ? directorioVideo56
... 
*** comprobamos que ahora, al tener permisos de lectura para el mundo el wd lionel, con testuser podemos leer el contenido de este directorio

-------------------------

- intentamos con su tomar la identidad de root vvv

lionel@lionel-ubuntu:~$ su root
Password: [Ctrl + c]

*** lo primero que nos va a pedir la shell es la contraseña de root y nosostros no la sabemos
*** en ubuntu y en practicamente todas las distribuciones de linux nuevas (excepto aquellas que estan orientadas a cosas muy concretas, por ejemplo la seguridad) la contraseña de la cuenta root va a estar bloqueada por defecto
*** esto significa que no vamos a poder iniciar sesion como root directamente o utilizar el comando su para convertirnos en usuario root 

lionel@lionel-ubuntu:~$ sort /etc/passwd | grep root:x
root:x:0:0:root:/root:/bin/bash

*** sin embargo, dado que existe esta cuenta de root es posible que nosotros ejecutemos comandos haciendonos pasar por el usuario root, no con el comando su (como vimos anteriormente ejecutando con testdir un comando de lionel) sino con el comando sudo como vamos a ver a continuacion

CONCLUSION:
- nosotros no vamos a poder convertirnos en root "por defecto" (root@lionel-ubuntu:/) porque la contraseña esta bloqueada 
- podemos llegar a cambiar la contraseña de root, como vamos a ver despues
- pero lo ideal es que no usemos la cuenta de root 

--------------------

58. sudo

- podemos cambiar de identidad utilizando el comando sudo

- el comando sudo tiene algunas diferencias muy importantes en comparacion a su, sobre todo en terminaos de seguridad que pueden hacer que el comando sudo sea mucho mas aconsejable para determinadas circunstancias

testuser@lionel-ubuntu:~$ sudo cat /etc/shadow
[sudo] password for testuser: [4321]
testuser is not in the sudoers file.  This incident will be reported.

lionel@lionel-ubuntu:~$ sudo cat /etc/shadow
*** poner la palabra sudo del comando lo que va a hacer es que el comando se ejecute en nombre de otro usuario 
*** de que usuario? vamos a ver que toda la definicion del funcionamiento de sudo (que privilegios podemos elevar, que comandos podemos ejecutar, en nombre de que usuario podemos hacerlo, etc) viene definido en el fichero /etc/sudoers y hablaremos sobre el en la siguiente clase

lionel@lionel-ubuntu:~$ head -n 5 /etc/shadow
head: cannot open '/etc/shadow' for reading: Permission denied
*** con lionel no tengo accesos a leet el fichero /etc/shadow 

lionel@lionel-ubuntu:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1567 mar 10 12:47 /etc/shadow
*** compruebo que el propietario de /etc/shadow es root y el grupo propietario es shadow, a quier lionel no pertenece, y que world (en donde se ubica lionel) no tiene ningun tipo de permiso respecto a este fichero

lionel@lionel-ubuntu:~$ sudo head -n 5 /etc/shadow
[sudo] password for lionel: [1234]
root:!:19604:0:99999:7:::
daemon:*:19576:0:99999:7:::
bin:*:19576:0:99999:7:::
sys:*:19576:0:99999:7:::
sync:*:19576:0:99999:7:::
*** entonces ejecuto el comando en nombre del usuairo root anteponiendo la palabra sudo, y ahora si puedo leer el fichero
*** entonces por defecto sudoers viene configurado en ubuntu de manera que yo con el usuario lionel cuando ejecuto sudo, como podemos ver aca, me va a pedir mi propia contraseña y cuando la introduzco me permite ejecutar este comando concreto (head -n 5 /etc/shadow) en nombre del usuario root

lionel@lionel-ubuntu:~$ su -c "cat /etc/shadow" root
Password: 
*** como vemos, con la logica de su no hubiera podido hacer esto mismo 

- la primera diferencia entre su y sudo, es que sudo es un comando con el que vamos a ejecutar otros camandos ejecutandolos en nombre de otro usuario

- la segunda diferencia, y muchisimo mas importante sobre todo en terminos de seguridad, es que sudo, para ejecutar un comando en nombre de otro usuario (como vimos en los ejemplos de cat y head para /etc/shadow en nombre de root), pide la contraseña del usuario que esta queriendo ejecutar el comando en nombre de otro (en estos ejemplos tengo que ingresar mi password, el de lionel), en vez de tener que ingresar la contraseña del usuario por quien lionel se esta queriendo hacer pasar, lo que sí pasa con su (como vimos en los ejemplos en los que ejecutamos comandos en nombre de lionel con el usuario testuser)
- esto en terminos de seguridad es muchisimo mas conveniente que tener que meter la contraseña del usuario root o de cualquier otro usuario que no sea la de quien esta queriendo ejecutar un comando para el que no tiene acceso, porque implica que el usuario lionel conozca las contraseñas de otros usuarios

- para que lionel pueda ejecutar comandos en nombre de root con el comando sudo, se logra configurando mediante el usuario root el fichero /etc/sudoers donde voy a indicar que el usuario lionel pueda elevar privilegios introduciendo su propia contraseña para realizar determinadas acciones

- sudo lo vamos a utilizar casi siempre que necesitemos asumir los provilegios del usuario root, aunque como vamos a ver mas adelante podriamos utilizarlo para asumir los privilegios de cualquier otro usuario

- tambien podemos utilizar una opcion que tiene sudo (que no es muy utilizada, para esto suele utilzarse su) para obtener una sesion interactiva, en este caso con el usuario que tengamos configurado en el fichero /etc/sudoers

lionel@lionel-ubuntu:~$ ls -l /etc/sudoers
-r--r----- 1 root root 1671 feb  8  2022 /etc/sudoers

lionel@lionel-ubuntu:~$ sudo -i
root@lionel-ubuntu:~# 
*** como podemos ver, estoy obteniendo una sesion interactiva siendo lionel, del usuario root 
*** observar como cambia el prompt == ~# 
*** cuando aparace # quiere decir que estamos con privilegios de superusuario
*** como vemos, esta vez no me ha pedido la contraseña de lionel porque la habia introducido antes para visualizar el fichero shadow, es como que se quedan cacheadas y la introduce automaticamente sin que tenga que ingresarla otra vez
*** como vemos, aunque la cuenta de root no tiene contraseña, utilizando sudo podemos obtener una shell interactiva en nombre de root

root@lionel-ubuntu:~# id
uid=0(root) gid=0(root) groups=0(root)
root@lionel-ubuntu:~# head -n 2 /etc/sudoers
#
# This file MUST be edited with the 'visudo' command as root.
*** como vemos, en la sesion interactiva de root gozamos de plenos privilegios

root@lionel-ubuntu:~# exit
logout
lionel@lionel-ubuntu:~$ 
*** exit para salir de la shell interactiva de root

CONCLUSION:
- no es recomendable que usemos la cuenta de root para absolutamente nada usando este metodo de sesion interactiva (sudo -i)
- de hecho y por seguridad, lo ideal es configurar el fichero sudoers para que no se pueda acceder a la shell interactiva de root

--------------------

59. sudoers

lionel@lionel-ubuntu:~$ ls -la /etc/sudoers
-r--r----- 1 root root 1671 feb  8  2022 /etc/sudoers

- a priori, sudoers nunca deberia ser modificado con editores como pico o nano
- de hecho, este fichero tiene permisos solo de lectura tanto para el user root como para el group root (usuario y grupo propietarios del fichero respectivamente), por lo que no sería posible modificarlo con los editores pico o nano (hize la prueba y efectivamente) vvv

- para editar este fichero tenemos que utilizar un comando especifico que se denomina visudo vvv

- abrimos el fichero con el comando visudo (lo que nos permite modificarlo en caso de ser necesario) y explicamos detalladamente cada una de las lineas NO comentadas y que por lo tanto van a realizar algun tipo de accion vvv

lionel@lionel-ubuntu:~$ sudo visudo
... # comentarios

Defaults        env_reset
*** esta linea indica que cuando usemos el comando sudo va a resetear las variables de entorno, es decir, resetea el entorno
*** las variables de entorno son una serie de variables que se pueden definir en la shell, en lo que se llama el entorno de la shell, y que tienen ciertas implicaciones de seguridad y por eso conviene resetearlas antes de ejecutar nada con privilegios elevados
Defaults        mail_badpass
*** esta linea indica que cuando se introduzca una contraseña erronea al utilizar el comando sudo se va a enviar un email a la cuenta que tengamos configurada en el sistema (en este caso no tenemos configurada ninguna) con lo cual esta linea para nuestro caso no es muy relevante
Defaults        secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin"
*** esta linea va a indicar las rutas donde se van a encontrar los ficheros ejecutables o lo que nosotros estemos tratando de ejecutar con sudo
*** aqui tenemos normalmente casi todas las rutas donde se encuentran los binarios del sistema (por ejemplo los comandos cat, ls o cualquiera de ellos)
Defaults        use_pty
*** esta linea indica que va a usar una pseudo tty que no tiene mucha relevancia para el funcionamiento del comando sudo o al menos para lo que nos interesa a nosotros
*** estas 4 lineas hasta aca no nos interesan demasiado, ya que no estan dictando ningun permiso de los que tiene sudo 

... # comentarios

*** aca vienen las lineas importantes del fichero sudoers vvv

# User privilege specification
root    ALL=(ALL:ALL) ALL
*** esta linea establece los privilegios de usuario
*** como vemos, a priori, root es el unico usuario establecido por defecto en el fichero sudoers
*** el primer campo de esta entrada (root) es al usuario al que se le van a aplicar las reglas del segundo campo ("ALL=(ALL:ALL) ALL")
*** desglose de ALL=(ALL:ALL) ALL vvv 
*** ALL #1 indica los hosts a los que se van a aplicar estos permisos (nostros tenemos un solo host, ya que estamos ejecutando ubuntu en una maquina local)
*** ALL #2 indica los usuarios para los que este usuario root va a poder ejecutar comandos en su nombre (en este caso root va a poder ejecutar comandos en nombre de todos los usuarios del sistema)
*** ALL #3 indica los grupos para los que este usuario root va a poder ejecutar comandos en su nombre (en este caso root va a poder ejecutar comandos en nombre de todos los grupos del sistema)
*** ALL #4 hace referencia a los comandos que va a poder ejecutar el usuario root (con ALL indicamos que va a poder ejecutar todos los comandos)
*** entonces esta regla (que es la menos restrictiva posible) esta indicando que el usuario root, utilizando el comando sudo e introduciendo su propia contraseña va a poder ejecutar todos los comandos que quiera (que se encuentren en las rutas de secure_path - unas lineas mas arriba en este mismo archivo -) en nombre de todos los usuarios, grupos y hosts del sistema (o sea, que va a poder comportarse como cualquier otro usuario)

# Members of the admin group may gain root privileges
%admin ALL=(ALL) ALL
*** toda entrada que empieze con % dentro de sudoers quiere decir que es un grupo
*** esta linea tiene que ver con el comportamiento que tienen los usuarios que pertenecen al grupo admin cuando utilizan sudo
*** esta configuracion de permisos se va a aplicar al grupo admin
*** indica que todos los usuarios del grupo admin y que utilizen el comando sudo, cuando introduzcan su contraseña, va aplicarse la siguiente regla vvv 
*** van a poder ejecutar todos los comandos (ALL #3) en nombre de cualquier usuario (ALL #2) para cualquier host (ALL #1)

# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL
*** cualquier usuario que pertenezca al grupo sudo va a poder ejecutar cualquier comando (ALL #4) en nombre de cualquier usuario (ALL #2), en nombre de cualquier grupo (ALL #3) y para cualquier host (ALL #1)

# See sudoers(5) for more information on "@include" directives:

@includedir /etc/sudoers.d
*** esta linea nos dice que si nosotros queremos añadir permisos adicionales, en lugar de modificar este fichero propiamente (que es el que viene por defecto), lo que podemos hacer es crear un directorio nuevo "sudoers.d" para agregar los nuevos permisos ahí, y esta entrada @includedir va a incluir automaticamente al final de sudoers el contenido de lo que haya dentro de sudoers.d, de manera que tengamos los ficheros personalizados bien ordenados y gestioados en este directorio sudores.d y no modifiquemos constantemente el fichero sudoers que deberia mantenerse por defecto (en mi SO, el directorio /etc/sudores.d ya existe)

-----------------------------

lionel@lionel-ubuntu:~$ id
uid=1000(lionel) gid=1000(lionel) groups=1000(lionel),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),135(lxd),136(sambashare)
*** lionel puede ejecutar comandos en nombre de root, porque como vemos, en ubuntu esta agregado por defecto al grupo sudo 

%sudo   ALL=(ALL:ALL) ALL
*** como vimos en sudoers, los usuarios incluidos en el grupo sudo pueden ejectutar cualquier comando, en nombre de culquier usuario o grupo, en cualquier host
*** por eso lionel puede ejecutar comandos en nombre de root

-----------------------------

- agregamos a testuser a sudoers creando un fichero nuevo (lo llamamos config) dentro de /etc/sudoers.d vvv

lionel@lionel-ubuntu:~$ ls -ld /etc/sudoers.d/
drwxr-xr-x 2 root root 4096 mar 12 23:31 /etc/sudoers.d/

lionel@lionel-ubuntu:~$ ls -l /etc/sudoers.d/
total 8
-r--r----- 1 root root 1096 feb  8  2022 README

lionel@lionel-ubuntu:~$ sudo visudo /etc/sudoers.d/config
testuser ALL=(ALL:ALL) /usr/bin/cat

lionel@lionel-ubuntu:~$ sudo cat /etc/sudoers.d/config 
testuser ALL=(ALL:ALL) /usr/bin/cat
*** le damos privilegios a testuser para que pueda ejecutar el comando /usr/bin/cat en nombre de cualquier usuario y cualquier grupo del sistema, desde (?) cualquier host 

lionel@lionel-ubuntu:~$ type cat
cat is hashed (/usr/bin/cat)
*** aca vemos que el binario cat se encuentra efectivamente en /usr/bin/cat

testuser@lionel-ubuntu:~$ sudo head -n 5 /etc/shadow
Sorry, user testuser is not allowed to execute '/usr/bin/head -n 5 /etc/shadow' as root on lionel-ubuntu.
testuser@lionel-ubuntu:~$ sudo cat /etc/shadow
root:!:19604:0:99999:7:::
daemon:*:19576:0:99999:7:::
bin:*:19576:0:99999:7:::
sys:*:19576:0:99999:7:::
...
*** aca verificamos que testuser ahora tiene privilegios para ejecutar el comando cat en nombre de root, pero no asi, por ejemplo el comando head

COMENTARIO FINAL vvv 
- lo normal no es añadir nuevos usuarios al fichero sudoers
- lo normal es añadir nuevos grupos y despues añadir esos usuarios a los grupos porque es muchisimo mas facil de gestionar vvv 

lionel@lionel-ubuntu:/etc/sudoers.d$ sudo usermod -aG sudo testuser
*** agrego con lionel en nombre de root, a testuser al grupo sudo 

lionel@lionel-ubuntu:/etc/sudoers.d$ su - testuser
Password: 
To run a command as administrator (user "root"), use "sudo <command>".
See "man sudo_root" for details.

testuser@lionel-ubuntu:~$ id
uid=1001(testuser) gid=1001(testuser) groups=1001(testuser),27(sudo)
testuser@lionel-ubuntu:~$ 

testuser@lionel-ubuntu:~$ head -n 3 /etc/shadow
head: cannot open '/etc/shadow' for reading: Permission denied
testuser@lionel-ubuntu:~$ sudo head -n 3 /etc/shadow
root:!:19604:0:99999:7:::
daemon:*:19576:0:99999:7:::
bin:*:19576:0:99999:7:::

--------------------

60. Gestión usuarios y grupos: useradd, groupadd, usermod, deluser...

- vamos a ver algunas de las operaciones basicas que podemos realizar tanto sobre usuarios como sobre grupos dentro de linux vvv 

60.1) Como añadir un nuevo usuario (useradd) vvv 

- en el video 57 vimos que podiamos agregar un nuevo usuario con el comando adduser vvv 

lionel@lionel-ubuntu:~$ sudo adduser testuser
...

- el comando adduser no va a estar disponible en todas las distribuciones de linux porque es un wraper (un envoltorio, una especie de interfaz) sobre un comando de un poquito mas bajo nivel que se denomina useradd 

- creo el usuario newuser con adduser vvv 

lionel@lionel-ubuntu:~$ sudo adduser newuser
Adding user `newuser' ...
Adding new group `newuser' (1002) ...
Adding new user `newuser' (1002) with group `newuser' ...
Creating home directory `/home/newuser' ...
Copying files from `/etc/skel' ...
New password: [9999]
BAD PASSWORD: The password is a palindrome
Retype new password: [9999] 
passwd: password updated successfully
Changing the user information for newuser
Enter the new value, or press ENTER for the default
	Full Name []: newuser
	Room Number []: 
	Work Phone []: 
	Home Phone []: 
	Other []: 
Is the information correct? [Y/n] y
lionel@lionel-ubuntu:~$ 

*** a modo de prueba cree al usuario felipe con useradd vvv

lionel@lionel-ubuntu:~$ sudo useradd -m felipe
lionel@lionel-ubuntu:~$ tail -n 4 /etc/passwd
lionel:x:1000:1000:lionel,,,:/home/lionel:/bin/bash
testuser:x:1001:1001:testuser,,,:/home/testuser:/bin/bash
newuser:x:1002:1002:newuser,,,:/home/newuser:/bin/bash
felipe:x:1003:1003::/home/felipe:/bin/sh
lionel@lionel-ubuntu:~$ ls -ld /home/felipe/
drwxr-x--- 2 felipe felipe 4096 mar 13 00:14 /home/felipe/
*** como vemos, lo agregue correctamente con directorio de trabajo (-m) (pero no me dio opcion a ingresar una contraseña)
*** luego lo borre con "userdel felipe", y a su vez tuve que borrar manualmente en nombre de root su directorio de trabajo (primero borrar a mano archivos ocultos dentro de este directorio)

-----------------------------

60.2) Como añadir nuevos grupos (groupadd)

- vamos a tener 2 comandos principales:
    - groupadd -> el comando de bajo nivel por decirlo asi 
    - addgroup -> funcionalidad de alto nivel 

----------

- creo el grupo newgroup vvv 

lionel@lionel-ubuntu:~$ sudo addgroup newgroup
Adding group `newgroup' (GID 1003) ...
Done.
lionel@lionel-ubuntu:~$ 

lionel@lionel-ubuntu:~$ tail -n 10 /etc/group
geoclue:x:131:
pulse:x:132:
pulse-access:x:133:
gdm:x:134:
lxd:x:135:lionel
lionel:x:1000:
sambashare:x:136:lionel
testuser:x:1001:
newuser:x:1002:
newgroup:x:1003:

lionel@lionel-ubuntu:~$ groups
lionel adm cdrom sudo dip plugdev lpadmin lxd sambashare
*** groups nos saca los grupos del usuario actual

lionel@lionel-ubuntu:~$ groups testuser
testuser : testuser sudo
*** tambien nos permite ver los grupos a los que pertenece cualquier otro usario

----------

60.3) usermod 

- agrego a newuser a newgroup vvv 

ionel@lionel-ubuntu:~$ groups newuser
newuser : newuser
lionel@lionel-ubuntu:~$ id newuser
uid=1002(newuser) gid=1002(newuser) groups=1002(newuser)
lionel@lionel-ubuntu:~$ sudo usermod -a -G newgroup newuser
lionel@lionel-ubuntu:~$ groups newuser
newuser : newuser newgroup
lionel@lionel-ubuntu:~$ id newuser
uid=1002(newuser) gid=1002(newuser) groups=1002(newuser),1003(newgroup)
*** ahora vemos que newuser pertenece al grupo primario newuser y al grupo secundario newgroup

- la diferencia principal entre un grupo primario y un grupo secundario es que el grupo primario es el que se va a especificar cuando un usuario cree archivos (el grupo propietario del archivo sera el grupo primario del usuario) 

----------

- cambiamos el grupo primario de newuser vvv 

lionel@lionel-ubuntu:~$ sudo usermod -g newgroup newuser
lionel@lionel-ubuntu:~$ id newuser
uid=1002(newuser) gid=1003(newgroup) groups=1003(newgroup)
*** se cambio correctamente el grupo primario pero se perdio el grupo primario anterior (el profesor no explica como evitarlo, hice un par de pruebas pero no funcionaron)

----------

- cambiamos el nombre de un usuario vvv

lionel@lionel-ubuntu:~$ sudo usermod -l newuser2 newuser
lionel@lionel-ubuntu:~$ tail -n 3 /etc/passwd
lionel:x:1000:1000:lionel,,,:/home/lionel:/bin/bash
testuser:x:1001:1001:testuser,,,:/home/testuser:/bin/bash
newuser2:x:1002:1003:newuser,,,:/home/newuser:/bin/bash

----------

- cambiamos el working directory de un usuario vvv

lionel@lionel-ubuntu:~$ sudo usermod -d /home/lionel newuser2
lionel@lionel-ubuntu:~$ tail -n 3 /etc/passwd
lionel:x:1000:1000:lionel,,,:/home/lionel:/bin/bash
testuser:x:1001:1001:testuser,,,:/home/testuser:/bin/bash
newuser2:x:1002:1003:newuser,,,:/home/lionel:/bin/bash

----------

- cambiamos el uid de un usuario vvv

lionel@lionel-ubuntu:~$ sudo usermod -u 250 newuser2
lionel@lionel-ubuntu:~$ tail -n 3 /etc/passwd
lionel:x:1000:1000:lionel,,,:/home/lionel:/bin/bash
testuser:x:1001:1001:testuser,,,:/home/testuser:/bin/bash
newuser2:x:250:1003:newuser,,,:/home/newuser:/bin/bash
lionel@lionel-ubuntu:~$ id newuser2
uid=250(newuser2) gid=1003(newgroup) groups=1003(newgroup)

----------

- bloqueamos un usuario vvv

lionel@lionel-ubuntu:~$ sudo usermod -L nombre_usuario 
*** con este comando bloqueamos un usuario
*** L -> Lock

lionel@lionel-ubuntu:~$ sudo usermod -U nombre_usuario 
*** con este comando desbloqueamos un usuario
*** U -> Unlock

----------

- cambio cambiar la contraseña el passwordd de un usuario vvv

lionel@lionel-ubuntu:~$ sudo passwd newuser2
New password: 
BAD PASSWORD: The password is a palindrome
Retype new password: 
passwd: password updated successfully
lionel@lionel-ubuntu:~$ su - newuser2 
Password: 
newuser2@lionel-ubuntu:~$ 

----------

60.4) deluser y delgroup 

*** proceso de borrado correcto de un grupo y de un ususario (minuto 13')

lionel@lionel-ubuntu:~$ sudo delgroup newgroup
/usr/sbin/delgroup: `newuser2' still has `newgroup' as their primary group!
lionel@lionel-ubuntu:~$ tail -n 5 /etc/group
lionel:x:1000:
sambashare:x:136:lionel
testuser:x:1001:
newuser:x:1002:
newgroup:x:1003:newuser2
lionel@lionel-ubuntu:~$ id newuser2 
uid=250(newuser2) gid=1003(newgroup) groups=1003(newgroup)
lionel@lionel-ubuntu:~$ sudo deluser newuser2
Removing user `newuser2' ...
Done.
lionel@lionel-ubuntu:~$ tail -n 5 /etc/passwd
gnome-initial-setup:x:126:65534::/run/gnome-initial-setup/:/bin/false
hplip:x:127:7:HPLIP system user,,,:/run/hplip:/bin/false
gdm:x:128:134:Gnome Display Manager:/var/lib/gdm3:/bin/false
lionel:x:1000:1000:lionel,,,:/home/lionel:/bin/bash
testuser:x:1001:1001:testuser,,,:/home/testuser:/bin/bash
lionel@lionel-ubuntu:~$ tail -n 5 /etc/group
lionel:x:1000:
sambashare:x:136:lionel
testuser:x:1001:
newuser:x:1002:
newgroup:x:1003:
lionel@lionel-ubuntu:~$ sudo delgroup newgroup
Removing group `newgroup' ...
Done.
lionel@lionel-ubuntu:~$ tail -n 5 /etc/group
lxd:x:135:lionel
lionel:x:1000:
sambashare:x:136:lionel
testuser:x:1001:
newuser:x:1002:
lionel@lionel-ubuntu:~$ sudo delgroup newuser
Removing group `newuser' ...
Done.
lionel@lionel-ubuntu:~$ tail -n 5 /etc/group
gdm:x:134:
lxd:x:135:lionel
lionel:x:1000:
sambashare:x:136:lionel
testuser:x:1001:

---------- 

lionel@lionel-ubuntu:~$ sudo deluser --remove-home newuser2
*** con --remove-home podria haber borrado ademas el WD de newuser2

lionel@lionel-ubuntu:~$ sudo deluser --remove-all-files newuser2
*** con --remove-all-files podria haber borrado todos los ficheros y directorios creados por el usuario newuser2

---------- 

lionel@lionel-ubuntu:~$ ls /home/
lionel  newuser  testuser
lionel@lionel-ubuntu:~$ ls -la /home/newuser/
ls: cannot open directory '/home/newuser/': Permission denied
lionel@lionel-ubuntu:~$ sudo ls -la /home/newuser/
total 28
drwxr-x--- 2  250 1003 4096 mar 13 01:01 .
drwxr-xr-x 5 root root 4096 mar 13 00:18 ..
-rw------- 1  250 1003  109 mar 13 01:02 .bash_history
-rw-r--r-- 1  250 1003  220 mar 13 00:02 .bash_logout
-rw-r--r-- 1  250 1003 3771 mar 13 00:02 .bashrc
-rw------- 1  250 1003   20 mar 13 01:01 .lesshst
-rw-r--r-- 1  250 1003  807 mar 13 00:02 .profile
lionel@lionel-ubuntu:~$ sudo rm /home/newuser/
rm: cannot remove '/home/newuser/': Is a directory
lionel@lionel-ubuntu:~$ sudo rm -rf /home/newuser/
lionel@lionel-ubuntu:~$ ls /home/
lionel  testuser
*** borro el WD de newuser2 manualmente

--------------------

61. Cambio de propietario: chown y chgrp

- con chown podemos cambiar tanto el usuario como el grupo propietario de cualquier fichero o directorio vvv

- pruebas sobre ficheros vvv 

lionel@lionel-ubuntu:~$ echo "fichero de prueba" > ficheroVideo61.txt
lionel@lionel-ubuntu:~$ ls -la ficheroVideo61.txt 
-rw-rw-r-- 1 lionel lionel 18 mar 13 01:17 ficheroVideo61.txt
lionel@lionel-ubuntu:~$ chmod 770 ficheroVideo61.txt 
lionel@lionel-ubuntu:~$ ls -la ficheroVideo61.txt 
-rwxrwx--- 1 lionel lionel 18 mar 13 01:17 ficheroVideo61.txt
lionel@lionel-ubuntu:~$ cat ficheroVideo61.txt 
fichero de prueba

lionel@lionel-ubuntu:~$ chown testuser ficheroVideo61.txt 
chown: changing ownership of 'ficheroVideo61.txt': Operation not permitted
lionel@lionel-ubuntu:~$ sudo chown testuser ficheroVideo61.txt 
*** cambio al propietario del fichero

lionel@lionel-ubuntu:~$ ls -la ficheroVideo61.txt 
-rwxrwx--- 1 testuser lionel 18 mar 13 01:17 ficheroVideo61.txt

lionel@lionel-ubuntu:~$ cat ficheroVideo61.txt 
fichero de prueba
*** puedo seguir leyendo el fichero con lionel porque pertenece al grupo propietario

lionel@lionel-ubuntu:~$ sudo chown :testuser ficheroVideo61.txt 
lionel@lionel-ubuntu:~$ ls -la ficheroVideo61.txt 
-rwxrwx--- 1 testuser testuser 18 mar 13 01:17 ficheroVideo61.txt
*** cambio el grupo propietario del fichero

lionel@lionel-ubuntu:~$ cat ficheroVideo61.txt 
cat: ficheroVideo61.txt: Permission denied
*** ahora lionel pertenece al mundo, y por lo tanto no tiene permisos de lectura sobre el fichero

lionel@lionel-ubuntu:~$ sudo chown lionel:lionel ficheroVideo61.txt 
lionel@lionel-ubuntu:~$ ls -la ficheroVideo61.txt 
-rwxrwx--- 1 lionel lionel 18 mar 13 01:17 ficheroVideo61.txt
lionel@lionel-ubuntu:~$ cat ficheroVideo61.txt 
fichero de prueba
*** cambio usuario y grupo propietario del fichero con un solo comando

---------- 

- pruebas sobre directorios vvv 

lionel@lionel-ubuntu:~$ mkdir dirVideo61
lionel@lionel-ubuntu:~$ ls -lad dirVideo61/
drwxrwxr-x 2 lionel lionel 4096 mar 13 01:28 dirVideo61/

lionel@lionel-ubuntu:~$ sudo chown testuser: dirVideo61/
*** cambio usuario y grupo propietario del directorio con un solo comando (con esta notacion, por defecto se adjudica la propiedad al grupo primario del nuevo user owner)

lionel@lionel-ubuntu:~$ ls -lad dirVideo61/
drwxrwxr-x 2 testuser testuser 4096 mar 13 01:28 dirVideo61/

COMENTARIO FINAL vvv 
- antiguamente, para cambiar el grupo propietario de un fichero o directorio se utilizaba el comando chgrp 
- sigue funcionando por temas de retrocompatibilidad vvv

lionel@lionel-ubuntu:~$ sudo chgrp root dirVideo61/
lionel@lionel-ubuntu:~$ ls -lad dirVideo61/
drwxrwxr-x 2 testuser root 4096 mar 13 01:28 dirVideo61/

--------------------

62. Caso Práctico: Explotando el bit setuid

62.1) creo el ejecutable al que voy a añadirle el bit setuid vvv

lionel@lionel-ubuntu:~$ pico ficheroSetuidOwnerLionel.c
#include <stdio.h>
#include <sdtlib.h>
#include <sys/types.h>
#include <unistd.h>

int main()
{
   setuid(0);
   system("ls /home/lionel")
   return 0;
}
lionel@lionel-ubuntu:~$ ls -l ficheroSetuidOwnerLionel.c 
-rw-rw-r-- 1 lionel lionel 154 mar 14 08:00 ficheroSetuidOwnerLionel.c
*** Creamos un ejecutable en C, en el WD de lionel

*** Por qué extension .c? 
Porque este fichero va a contener un programa escrito en el lenguaje de programacion de alto nivel C 

*** Porque en C y no en shell script? 
Cuando añadimos el bit setuid sobre un binario, sobre un ejecutable, lo que va a ser el resultado de compilar este programa fichero.c
Cuando ejecutemos ese binario, por ejemplo, con el usuario lionel, si ese binario tiene como propietario a root, esa ejecucion se hara en nombre de root 
Sin embargo, cuando añadimos el setuid a un shell script la cosa cambia, y a pesar de que el usuario propietario de ese shell script sea root, si yo ejecuto ese shell script con el usuario lionel, esa ejecucion se hara en nombre de lionel y no de root
Es decir, el bit setuid no funciona de la manera que hemos visto cuando hablamos de shell scripts
Esta es una medida de seguridad que ha incorporado el SO linux para evitar que se puedan realizar acciones como vamos a realizar en este caso practico


62.2) Lo siguiente que vamos a hacer es compilar este fichero para transformallo en un ejecutable vvv  
para esto nos convertimos en root, porque este fichero.c es propiedad de lionel, y en este caso nos interesa que el resultado de compilar este fichero.c (generar un ejecutable), sea propiedad de root, para despues añadirle el setuid y luego ejecutarlo con cualquier otro usuario en nombre de root  vvv

lionel@lionel-ubuntu:~$ sudo su
[sudo] password for lionel: [1234]
root@lionel-ubuntu:/home/lionel# 

62.3) vamos a utilizar la suite de gcc que incluye el compilador de C que viene por defecto en linux para compilar este programita vvv
*** Una "suite" se refiere a un conjunto o colección de herramientas, programas o aplicaciones relacionadas que se ofrecen como un paquete integrado. (ChatGTP)
*** En el contexto de GCC (GNU Compiler Collection), se puede considerar como una "suite" porque no se trata solo de un compilador individual, sino de un conjunto de compiladores y herramientas relacionadas con la compilación que están diseñadas para funcionar juntas para proporcionar un entorno de desarrollo completo para varios lenguajes de programación. (ChatGTP)

root@lionel-ubuntu:/home/lionel# gcc ficheroSetuidOwnerLionel.c -o ficheroSetuidOwnerLionelEjecutable
Command 'gcc' not found, but can be installed with:
apt install gcc
*** verifico que no tendgo instalado gcc

root@lionel-ubuntu:/home/lionel# sudo apt install gcc
Reading package lists... Done
Building dependency tree... Done
...
*** instalo gcc

root@lionel-ubuntu:/home/lionel# gcc ficheroSetuidOwnerLionel.c -o ficheroSetuidOwnerLionelEjecutable
*** con -o podemos ejecutar el fichero resultante, el ejecutable resultante 
*** con este comando convertimos el fichero ficheroSetuidOwnerLionel.c en el ejecutable ficheroSetuidOwnerLionelEjecutable

root@lionel-ubuntu:/home/lionel# ls -la ficheroSetuidOwnerLionel.c; ls -la ficheroSetuidOwnerLionelEjecutable 
-rw-rw-r-- 1 lionel lionel 155 mar 14 20:21 ficheroSetuidOwnerLionel.c
-rwxr-xr-x 1 root root 16024 mar 14 20:21 ficheroSetuidOwnerLionelEjecutable
*** verifico que conservo el fichero de extension .c de lionel y se ha creado un ejecutable a partir de este propiedad de root 
*** recordar que a pesar de tener el bit setuid si nosotros queremos ejecutar un binario en nombre de otro usaurio tenemos que tener tambien permisos de ejecucion setuid vvv

root@lionel-ubuntu:/home/lionel# chmod u+s ficheroSetuidOwnerLionelEjecutable 
*** con root, le damos permisos setuid al ejecutable (notacion explicada en VIDEO 56, linea 2029 aprox )

root@lionel-ubuntu:/home/lionel# ls -la ficheroSetuidOwnerLionelEjecutable 
-rwsr-xr-x 1 root root 16024 mar 14 20:21 ficheroSetuidOwnerLionelEjecutable
*** compruebo que el bit setuid se aplico correctamente para el ejecutable

root@lionel-ubuntu:/home/lionel# mv ficheroSetuidOwnerLionelEjecutable /usr/bin/
*** para que este binario encaje con la ruta en la que se encuentran los binarios del sistema movemos el ejecutabe a /usr/bin

root@lionel-ubuntu:/home/lionel# ls -la /usr/bin/ficheroSetuidOwnerLionelEjecutable 
-rwsr-xr-x 1 root root 16024 mar 14 20:21 /usr/bin/ficheroSetuidOwnerLionelEjecutable
*** verifico que se movio correctamente


lionel@lionel-ubuntu:~$ ficheroSetuidOwnerLionelEjecutable
...
*** ejecuto el ececutable correctamente
*** podemos ejecutarlo sin indicar la ruta absoluta (/usr/bin/...) porque por default, cuando introducimos un comando en la terminal sin pasarle ruta absoluta, la shell revisa en todas las rutas de la variable de entorno PATH si lo ingresado se corresponde con algun ejecutable y, como movimos este ejecutable a /usr/bin, lo encuentra y ejecuta su contenido (el codigo fuente que escribimos en C)
*** entonces "ficheroSetuidOwnerLionelEjecutable" es un ejecutable al igual que "cd", "cat", "ls", "head", etc., y siempre la shell va a buscar a estos comandos a las rutas definidas en PATH

lionel@lionel-ubuntu:~$ env
*** lista por pantalla todas las variables de entorno del SO

lionel@lionel-ubuntu:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
*** imprimo el contenido de la variable de entorno PATH
*** entre estas rutas enconctraremos los comandos o ejecutables del sistema

lionel@lionel-ubuntu:~$ ls -la /usr/bin/ls; ls -la /usr/bin/ficheroSetuidOwnerLionelEjecutable 
-rwxr-xr-x 1 root root 138208 feb  7  2022 /usr/bin/ls
-rwsr-xr-x 1 root root 16024 mar 14 20:21 /usr/bin/ficheroSetuidOwnerLionelEjecutable

-------------------------------------------

- probablemente un atacante lo primero que haria cuando entre a una maquina linux y quiera explotar este tipo de problemas de seguridad seria buscar todos los ejecutables que hay en el sistema o todos los ficheros que tienen el bit setuid vvv

find / -type f -perm -4001 2> /dev/null
...
/usr/bin/mount
/usr/bin/ficheroSetuidOwnerLionelEjecutable
/usr/bin/gpasswd
...
*** /            || desde la raiz 
*** -type f      || para cualquier fichero 
*** -perm -4001  || para buscar por permisos (en este caso con el bit setuid y permisos de ejecucion para el mundo)
*** 2> /dev/null || redirijo los errores (/dev/stderr) a /dev/null para que no se listen por pantalla (/dev/null es un fichero especial, un CARACTER DEVICE FILE (una "c" en lugar de "-"), utilizado para estos casos (VIDEO 42))
*** 2            || hace referencia a /proc/self/fd/2 (recordar que los errores son enviados a /dev/stderr, y que este es un soft link a /proc/self/fd/2)
*** >            || es un operador de redireccion 

- el comando anterior nos lista todos los ficheros de nuestro SO linux con el bit setuid activado
- como vemos, listo el ejecutable que generamos con root (/usr/bin/ficheroSetuidOwnerLionelEjecutable)
- el atacante, va a identificar que no es un ejecutable propio del sistema, y es el primero que se va a poner a mirar vvv

lionel@lionel-ubuntu:~$ cat /usr/bin/ficheroSetuidOwnerLionelEjecutable 
@@@@�``��   ���-�=�=`h�-�=�=�8880hhhDDS�td8880P�td   44Q�tdR�td�-�=�=PP/lib64/ld-linux-x86-64.so.2 GNU���GNU�)H�d��Ӡ��,Ղ��G�ՙGNU��e�mQ "m | )"__cxa_finalize__libc_start_mainsystemsetuidlibc.so.6GLIBC_2.2.5GLIBC_2.34_ITM_deregisterTMCloneTable__gmon_start___ITM_registerTMCloneTable0u�i	:���F�`@�?�?�?�?�?�?�?��H�H��/H��t��H���5�/��%�/��h���������h�����������%�/D����%]/D����%U/D��1�I��^H��H���PTE1�1�H�=��3/�f.�H�=Y/H�R/H9�tH�/H��t	�����H�=)/H�5"/H)�H��H��?H��H�H��tH��.H����fD�����=�.u+UH�=�.H��t
... 
*** como vemos, el contenido de un ejecutable (un binario), no es legible, y por ejemplo cat o pico, no le serviria al atacante 
*** esto ya no es codigo, no es shell script, esto es un ejecutable, un binario 

-------------------------------------------

¿Como saber que esta haciendo un binario?

- con el comando strings (viene instalado por defecto)
- este comando aplicado a un binario, va a listar por terminal todas las cadenas de texto que tiene el ejecutable 
- estas cadenas de texto pueden referenciar cualquier cosa 
- si indagamos, encontramos la cadena de texto "ls /home/lionel", que es concretamente la funcionalidad que tiene nuestro binario vvv

lionel@lionel-ubuntu:~$ strings /usr/bin/ficheroSetuidOwnerLionelEjecutable 
... 
u+UH
ls /home/lionel
:*3$"
...
*** 

-------------------------------------------

- ahora mismo con lionel o testuser, puedo ejectutar este binario (propiedad de root) porque el mundo tiene permisos de ejecucion 
- ademas, como este binario tiene el bit setuid activado, cualquier usuario que lo ejecute, lo esta haciendo en nombre de root, con privilegios elevados

- entonces la ejecucion de este binario ejecuta ls /home/lionel, entonces la shell busca en PATH y encuentra el ejecutable ls en /usr/bin, y al encontrarlo, finalmente lo ejecuta 

- aca lo que sucede es que esta variable de entorno PATH la podemosm modificar sin permisos elevados 
- esto quiere decir que en PATH cualquier usuario puede añadir otras rutas en las que la shell buscase un binario ls o cualquier otro ejecutable cuando alguien este queriendo ejecutar ese comando 

- y yo (lionel) puedo crearme mi propio ejecutable ls (por ejemplo dentro de mi home) que haga otra cosa distinta que lo que hace el ls default (y que se encuentra en el ejecutable de root con el bit setuid activado, que implica que cualquier usuario que ejecute el binario lo estara haciendo en nombre de root)

- y eso es loque vamos a hacer: creo un fichero ls dentro de mi WD vvv 

lionel@lionel-ubuntu:~$ pico "ls"
#!/bin/bash 

/bin/bash -i
lionel@lionel-ubuntu:~$
*** esto APRANTEMENTE tiene que ver con shell scripting (en el ejercicio del VIDEO 37 hay un primer ejemplo que parece ser el mismo lenguaje) 

lionel@lionel-ubuntu:~$ cat ls
#!/bin/bash 

/bin/bash -i

- mi comando ls lo que hace es que saca una consola interactiva
- es decir, ejecuta "/bin/bash" (la shell bash) y nos la devuelve para que nosotros podamos interactuar

- ¿que va a ocurrir aca?

lionel@lionel-ubuntu:~$ ls -la ls
-rw-rw-r-- 1 lionel lionel 27 mar 16 19:22 ls
*** los permisos del profesor son rwxr-xr-x (755), los mios 664. Intente configurar mis permisos por default en 775 con umask pero aparentemente no me deja modificar permisos de ejecucion (deje pregunta en VIDEO 55)

lionel@lionel-ubuntu:~$ chmod 755 ls
lionel@lionel-ubuntu:~$ ls -la ls
-rwxr-xr-x 1 lionel lionel 27 mar 16 19:22 ls
*** le cambie los permisos y ahora si tengo permisos de ejecucion para usuario, grupo y mundo

- agrego al inicio de la cadena de la variable de entorno PATH la ruta /home/lionel vvv

lionel@lionel-ubuntu:~$ export PATH=/home/lionel:$PATH
lionel@lionel-ubuntu:~$ echo $PATH
/home/lionel:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin
*** esto lo puedo hacer con lionel porque para editar una variable de entorno no necesito privilegios de administracion

lionel@lionel-ubuntu:~$ ficheroSetuidOwnerLionelEjecutable

CONCLUSION:
- ejecuto el binario ficheroSetuidOwnerLionelEjecutable (en /usr/bin, propiedad de root, con permisos de ejecucion para todo mundo y con el bit setuid - cualquier usuario que ejecute este binario lo hara en nombre de root)
- este binario ejecuta "ls /home/lionel", que muestra el contenido del WD de lionel 

- ahore bien, el atacante accedió a la cuenta de dummyuser y descubrio esta vulnerabilidad en el binario propiedad de root (que puede crear un unevo comando ls con otros fines)
- entonces crea un ejecutable ls en /home/dummyuser que devuelve una shell de bash  
- luego modifica la variable de entorno PATH y agrega al inicio la ruta al WD de dummyuser 
- ahora cuando el atacante ejecute el ficheroSetuidOwnerLionelEjecutable (el ejecutable de root, con plenos permisos de ejecucion y bit setui), se va a ejecutar el comando ls, entonces la shell va a buscar en PATH la ubicacion de este comando, y la va a encontrar en la primera ruta de la variable de entorno (/home/userdummy) (modificacion del atacante) por lo que se ejecutara el ls de /home/userdummy y no el de /usr/bin
- con esto el atacante ha accedido al sistema como root con plenos privilegios pra hacer lo que quiera

--------------------

64. Procesos en Linux 

- linux, como practicamente cualquier SO moderno, es un sistema multitarea 
- esto quiere decir que nos va a provocar la ilusion de que podemos estar ejecutando diferentes programas al mismo tiempo y realizando diferentes tareas a la vez
- sin embargo, estos programas van a requerir el consumo de diferentes recursos de nuestro equipo (por ejemplo la CPU) y este consumo no se va a hacer de manera simultanea, sino que lo va a ir gestionando el kernel de nuestro SO y lo va a ir asignando de manera secuencial a los diferenctes programas que se encuentren en ejecucion 
- a nosotros nos parece que todos los programas que tenemos en uso (por ejemplo Firefox, la terminal, Postman) se estan ejecutando al mismo tiempo porque el kernel hace el cambio de asignacion de recursos tan rapido (en cuestion de milisegundos) que a nosotros no nos da tiempo a percibirlo y nos da la impresion de que todo se esta ejecutando al mismo tiempo (pero realmente no, esta habiendo este cambio de recursos)

notas de holaMundo vvv
- Cada SO cuenta con 3 partes:
- 1era capa (o capa inferior) -> Hardware fisico de la computadora (tarjeta de red, procesador, memoria RAM, etc.)
- 2da capa -> Kernel
    -> es el encargado de comunicar el Hardware Fisico con las Aplicaciones
    -> se va a encargar de asignarle los recursos necesarios a las Aplicaciones (por ej., si una app corriendo (proceso) necesita x cantidad de RAM, el Kernel se la asignara)
- 3ra capa -> Aplicaciones

PROGRAMA
- un programa va a ser generalmente un ejecutable, una pieza de codigo fuente, un binario, que se encuentra almacenado en el disco duro de nuestro ordenador y que no tiene por que estar en ejecucion

PROCESO 
- en el momento en que yo ejecuto un programa (por ejemplo ls, cat, emacs, etc) pasas a ser un proceso
- es decir, un proceso va a ser una instancia activa, en ejecucion, de un programa

- ¿Para que sirven los procesos?
- son las estructuras que utiliza el kernel para ir gestionando todo lo uque hablamos anteriormente (la asignacion de recursos, organizar la actividad que estan realizando, los ficheros que estan abriendo, etc)

CONCLUSION: un programa es cualquier archivo ejecutable que tenemos dentro del disco duro de nuestro equipo, y en el momento en el que lo ejecutamos se va a generar un proceso que va a comenzar a gestionar el kernel de nuestro SO

--------------------

- el kernel va a mantener diferente informacion sobre los procesos 
- va a mantener por ejemplo un registro de la memoria que esta asignada al proceso
- los archivos que tiene abiertos 
- el ejecutable a partir del cual se ejecuto ese proceso 
- un monton de informacion que se va a encontrar en /proc 
- concretamente cada uno de los procesos que nosostros generamos en linux van a tener tambien un identificador que se va a denominar PID (process id)

lionel@lionel-ubuntu:~$ ls /proc/
1     1585  1731  1868  200   249  496   6225  76    8215   buddyinfo      meminfo
1025  159   1737  187   201   250  497   6226  765   8216   bus            misc
...
*** estos directorios con numeros hacen referencia al PID de los diferentes procesos que se encuentran en ejecucion en este momento 
*** estas carpetas se crean dinamicamente cuando nosotros creamos un proceso y se eliminan cuando nosotros cerramos el proceso

--------------------

Ejemplo practico vvv

lionel@lionel-ubuntu:~$ emacs
*** (en una nueva ventana, se abrio el editor de texto emacs)
*** en este punto, he tomado el ejecutable de emacs, lo he ejecutado y he generado un proceso que es lo que estais viendo ahora mismo en ejecucion (referencia a la nueva ventana con el editor abierto)

lionel@lionel-ubuntu:~$ 
*** abro una nueva terminal (Ctrl + Alt + T) porque la otra la tenemos ocupada ejecutando este ejecutable, este binario (emacs)

lionel@lionel-ubuntu:~$ cd /proc/
lionel@lionel-ubuntu:/proc$ ls
1     1593  176   1896  2052  33   583   685   808   8638
... 
*** entre estos directorios numerados, se encuentra el correspondiente al proceso que esta ejecutando emacs 

lionel@lionel-ubuntu:/proc$ pidof emacs 
8629
*** la utilidad pidof nos permite conocer el id de cualquier programa que se encuentra en ejecucion (man pidof)

lionel@lionel-ubuntu:/proc$ cd 8629 
lionel@lionel-ubuntu:/proc/8629$ 
lionel@lionel-ubuntu:/proc/8629$ ls
arch_status         cpuset             limits      numa_maps      schedstat     task
attr                cwd                loginuid    oom_adj        sessionid     timens_offsets
cmdline 
... 
*** aqui esta toda la informacion que esta gestionando el kernel, asociada a este proceso que tenemos en ejecucion (emacs) 

lionel@lionel-ubuntu:/proc/8629$ cat cmdline 
emacslionel@lionel-ubuntu:/proc/8629$ 
*** por ejemplo, cmdline, nos devuelve el comando que se utilizo para ejecutar este proceso 

lionel@lionel-ubuntu:/proc$ cd 8629
bash: cd: 8629: No such file or directory
*** cerré la ventana del editor emacs, por lo tanto cerré el proceso, ese proceso ya no existe porque ese programa ya no esta en ejecucion 
*** trato de ingresar nuevamente al directorio asociado al proceso que esta ejecutando emacs y compruebo que este ya no existe

--------------------

65. Visualización estática de procesos

COMANDO ps:
- ps - report a snapshot of the current processes. (man ps)
- ps va a reportanrnos un snapshot de los procesos que se estan ejecutando en un momento determinado ()
- ps nos va a sacar una imagen de los procesos que se encuentran en ejecucion, que se encuentran dormidos, que se encuentran en general activos dentro de nuestro SO pero en el momento en el que yo he ejecutado ese comando, es decir, no va a ser una salida en tiempo real

lionel@lionel-ubuntu:~$ ps
    PID TTY          TIME CMD
   8912 pts/0    00:00:00 bash
   8918 pts/0    00:00:00 ps
*** como vemos, se listan solo 2 procesos (el 8912 que es la terminal en la que estamos escribiendo (bash), y el 8918 que es el que se ha generado como consecuencia de la ejecucion del comando ps) 
*** estos no son los dos unicos comandos en ejecucion, ya que si asi fuera, no estariamos viendo la interfaz grafica de ubuntu, la barra de tareas, etc 
*** lo que ocurre es que ps por defecto va a listar unicamente los procesos asociados a la terminal en la que estamos escribiendo 
*** PID = identificador de cada proceso
*** TTY = Tele Type Writer || esta relacionado con la terminal en la que se esta ejecutando ese proceso || pts/0 hace referencia a la terminal en la que estamos escribiendo
*** TIME = tiene que ver con el consumo de tiempo de CPU que estan haciendo estos procesos (ninguno de los dos esta consumiendo practicamente nada de CPU, y es porque ambos son procesos muy ligeros, procesos que no requieren mucho consumo de recursos)
*** CMD = es el comanando que ha generado ese proceso

lionel@lionel-ubuntu:~$ ps x
    PID TTY      STAT   TIME COMMAND
   1529 ?        Ss     0:01 /lib/systemd/systemd --user
... 
*** "ps x" lista todos los procesos que tenemos ejecutandose en el sistema y ademas nos añade la columna estado (STAT)

lionel@lionel-ubuntu:~$ emacs
*** en una segunda terminal ejecuto el proceso emacs 

- en la terminal anterior no vamos a ver en el listado la entrada asociada al proceso emacs ya que se trata de una imagen en el momento en que yo ejecuté ps x 
- vuelvo a ejecutar ps x en la consola anterior vvv

lionel@lionel-ubuntu:~$ ps x
    PID TTY      STAT   TIME COMMAND
...
   9167 pts/1    Sl+    0:00 emacs
   9202 pts/0    R+     0:00 ps x
lionel@lionel-ubuntu:~$ 
*** en esta nueva imagen que nos devuelve ps x vemos que aparece emacs como uno de los procesos que se encuentra activo 
*** observamos que el TTY del proceso emacs cambia porque emacs lo ejecutamos en una terminal distinta (pts/1) de la terminal donde ejecutamos ps x (pts/0)
*** STAT = todas las letras que forman parte del STAT (estado) de un proceso tienen un significado especial para ps y estan relacionadas con el estado en el que se encuentra cada proceso vvv 

lionel@lionel-ubuntu:~$ man ps
...
PROCESS STATE CODES
       Here are the different values that the s, stat and state output specifiers (header "STAT"
       or "S") will display to describe the state of a process:

               D    uninterruptible sleep (usually IO)
               I    Idle kernel thread
               R    running or runnable (on run queue)
               S    interruptible sleep (waiting for an event to complete)
               T    stopped by job control signal
               t    stopped by debugger during the tracing
               W    paging (not valid since the 2.6.xx kernel)
               X    dead (should never be seen)
               Z    defunct ("zombie") process, terminated but not reaped by its parent

       For BSD formats and when the stat keyword is used, additional characters may be displayed:

               <    high-priority (not nice to other users)
               N    low-priority (nice to other users)
               L    has pages locked into memory (for real-time and custom IO)
               s    is a session leader
               l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)
               +    is in the foreground process group
*** aqui tenemos todos los codigos de todas las letras que pueden aparecer en el estado (STAT)
*** el profesor explica verbalmente en detalle alguno de estoso significados (min 5'30" aprox)

lionel@lionel-ubuntu:~$ ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.3 166764 11900 ?        Ss   mar16   0:03 /sbin/init auto noprompt splash
... 
*** ps aux suele ser la combinacion de comandos mas utilizada para visualizar los estados de los procesos en un momento determinado (una imagen)
*** USER = usuario que ha ejecutado el proceso
*** %CPU = consumo de CPU del proceso en ese momento 
*** %MEM = consumo de memoria RAM del proceso en ese momento
*** VSZ = consumo de memoria virtual del proceso en ese momento   
*** RSS =
*** START = el comienzo de ejecucion de ese proceso
*** TIME = tiene que ver con el consumo de tiempo de CPU que estan haciendo estos procesos 
*** COMMAND = el comando que se utilizo para ejecutar el proceso

lionel@lionel-ubuntu:~$ ps aux | less 
...
*** podemos hacer un pipe a less para visualizar la lista de modo interactivo

lionel@lionel-ubuntu:~$ ps aux | tail -n 1
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
lionel      9293  0.0  0.0  10940  2304 pts/0    S+   15:35   0:00 tail -n 1
*** START = se trata de la hora en la que he ejecutado el comando (ahora mismo, Domingo 17 de Marzo de 2024 15:35 hs.)

--------------------

66. Visualización dinámica de procesos

- visualizacion dinamica quiere decir que vamos a poder estar viendo en tiempo real el consumo de recursos que esta haciendo cada proceso (consumo de CPU, de memoria, el tiempo que lleva en ejecucion, etc)

lionel@lionel-ubuntu:~$ man top
...
top - display Linux processes 
The  top  program  provides  a  dynamic real-time view of a running system.
...

lionel@lionel-ubuntu:~$ top
top - 22:45:43 up 14 min,  1 user,  load average: 0,04, 0,07, 0,10
Tasks: 299 total,   1 running, 298 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0,3 us,  0,2 sy,  0,0 ni, 99,3 id,  0,0 wa,  0,0 hi,  0,2 si,  0,0 st
MiB Mem :   3870,6 total,   1882,7 free,   1020,6 used,    967,3 buff/cache
MiB Swap:   2140,0 total,   2140,0 free,      0,0 used.   2563,7 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                                                                              
   1741 lionel    20   0 4445528 273068 138056 S   0,3   6,9   0:11.22 gnome-shell                                                                                                                          
      1 root      20   0  166788  11776   8192 S   0,0   0,3   0:02.40 systemd    
...
*** la salida de top nos ofrece una cabecera arriba con informacion general sobre nuestro sistema 
*** tabla con diversos valores de cada uno de los procesos que tenemos en ejecucion
*** esta informacion se actualiza cada 3 segundos por default (mas adelante veremos como setear este valor)

--------------------

- analisis de la cabecera vvv 

top - 22:50:05 up 18 min,  1 user,  load average: 0,00, 0,04, 0,08
Tasks: 290 total,   1 running, 289 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0,2 us,  0,0 sy,  0,0 ni, 99,8 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
MiB Mem :   3870,6 total,   1907,2 free,    995,4 used,    968,0 buff/cache
MiB Swap:   2140,0 total,   2140,0 free,      0,0 used.   2588,8 avail Mem 

top - 22:50:05 up 18 min,  1 user,  load average: 0,00, 0,04, 0,08
*** 22:50:05                       -> hora actual de nuestro sistema 
*** up 18 min                      -> tiempo que nuestro equipo lleva encendido 
*** 1 user                         -> la cantidad de usuarios que estan logueados (lionel)
*** load average: 0,00, 0,04, 0,08 -> por decirlo asi, es el numero de procesos que se encuentran en ejecucion y compartiendo CPU (CREO que representan porcentajes del total de procesos)
*** 0,00, 0,04, 0,08               -> cada uno de estos 3 numeros es la media por decirlo asi del numero de procesos en diferentes intervalos de tiempo 
*** 0,00                           -> en los ultimos 60 segundos 0.00 procesos compartiendo CPU
*** 0,04                           -> en los ultimos 5 minutos 0.04 procesos compartiendo CPU 
*** 0,08                           -> en los ultimos 15 minutos 0.08 procesos compartiendo CPU
*** si estos numeros se encuentran por debajo de 1, en general quiere decir que la maquina tiene bastantes recursos y esta bastante libre

Tasks: 290 total,   1 running, 289 sleeping,   0 stopped,   0 zombie
*** Tasks: 290 total -> aca tenemos el total de procesos que tenemos en ejecucion en nuestra maquina
*** 1 running        -> de los 290 procesos 1 esta corriendo
*** 289 sleeping     -> 289 procesos se encuentran dormidos, en estado de sleep
*** 0 stopped        -> 0 procesos parados 
*** 0 zombie         -> 0 zombies (hablaremos de esto mas adelante)

%Cpu(s):  0,2 us,  0,0 sy,  0,0 ni, 99,8 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
*** aca tenemos el consumo de CPU. Se va a dividir en diferentes valores
*** 0,2 us  -> el consumo de CPU que se realiza por procesos de usuarios (0.2%)
*** 0,0 sy  -> el consumo de CPU que esta realizando el sistema (0.0%), concretamente el kernel del sistema
*** 0,0 ni  -> el consumo de CPU de procesos nice, que por decirlo asi le ceden la CPU a otros procesos que tengan mas prioridad (0.0%)
*** 99,8 id -> el consumo de CPU que tenemos libre, es decir, que no se esta utilizando, 99.8%, lo que significa que esta maquina en este momento se encuentra con una carga de trabajo muy baja

MiB Mem :   3870,6 total,   1907,2 free,    995,4 used,    968,0 buff/cache
*** consumo de memoria RAM 
*** 3870,6 total      -> podemos ver los gigas que tiene esta maquina dedicados, casi 4GB (3870.6 megas)
*** 1907,2 free       -> 1907.2 megas libres (casi 2 GB)
*** 995,4 used        -> casi 1GB ocupado
*** 968,0 buff/cache  -> casi 1GB en buffer/cache

MiB Swap:   2140,0 total,   2140,0 free,      0,0 used.   2588,8 avail Mem 
*** aca tenemos la memoria de SWAP, para hacer SWAPING
2140,0 total     -> 2.1GB (ya hablamos de esto cuando hablamos del fichero de SWAPING, es decir, el fichero /swapfile)         
2140,0 free      -> 2.1GB libres    
0,0 used         -> 0GB usados  
2588,8 avail Mem -> disponible esto que tenemos por aqui

--------------------

- analisis de la tabla vvv 

  PID    USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                                                                              
    1    root      20   0  166788  11776   8192 S   0,3   0,3   0:02.45 systemd                                                                                                                              
   35    root      20   0       0      0      0 S   0,3   0,0   0:00.13 kcompactd0                                                                                                                           
  316    root      19  -1   64752  21296  19888 S   0,3   0,5   0:00.54 systemd-journal                                                                                                                      
  588    root      20   0  319908   9472   7936 S   0,3   0,2   0:03.38 vmtoolsd       
*** PID     -> process id del proceso, identificador del proceso
*** USER    -> owner del proceso
*** PR      -> prioridad con que asigna el kernel el consumo de CPU en funcion de lo importante que sea eese proceso | a mayor numero mayor prioridad, es decir, mas probabilidad de que el kernel le asigne CPU
*** NI      -> viene de NICE | a valor mas bajo, ese proceso es mas nice, mas bueno con el resto de procesos y les va a ceder el consumo de CPU a ellos (a menor NI, menor PR)
*** VIRT    -> consumo de memoria virtual
*** RES     -> consumo de memoria RAM en valores absolutos (KB)
*** SHR     -> shared memory | memoria compartida con otros procesos en valor absoluto (KB)
*** S       -> estado
*** %CPU    -> consumo en % de CPU 
*** %MEM    -> consumo en % de memoria RAM   
*** TIME+   -> el tiempo que lleva el proceso en ejecucion
*** COMMAND ->        

- el comando top siempre va a ordenar los procesos por consumo de CPU (%CPU)

- presionando "h" nos sale la ayuda del comando top 
- top nos permite ejecutar varias teclas, varias letras, que va n a realizar diferentes acciones de manera interactiva sobre la salida de top

- la "s" nos permite actualizar el tiempo de refresco
- la "u" nos permite filtrar los procesos por usuario
- la "e" nos permite cambiar las unidades de valores absolutos de VIRT, RES, etc (KB, MB, GB, TB y PT - peta bytes -)
- la "o" nos permite filtrar procesos por alguno de los campos de la tabla vvv
add filter #1 (ignoring case) as: [!]FLD?VAL PID=59 // + ENTER
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                       
    159 root      20   0       0      0      0 S   0,0   0,0   0:00.00 scsi_eh_4                     
   1595 lionel    20   0  238684   6400   5888 S   0,0   0,2   0:00.01 xdg-permission- 

- una vez que aplicamos un filtro, si queremos volver atras y aplicar otro debemos salit con Ctrl + c y volver a ejecutar top

- otro ejemplo de filtro con "o" vvv

add filter #1 (ignoring case) as: [!]FLD?VAL %MEM>1
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                       
   1741 lionel    20   0 4454460 278132 134632 S   3,7   7,0   0:32.21 gnome-shell                   
   2414 lionel    20   0  565368  62348  46792 S   1,3   1,6   0:13.90 gnome-terminal-      

--------------------

67. Interrupción de procesos

lionel@lionel-ubuntu:~$ emacs 
*** ejecutamos emacs (en primer plano, mas adelante la explicacion)

lionel@lionel-ubuntu:~$ emacs
^Clionel@lionel-ubuntu:~$ 
*** con Ctrl + c interrumpimos el proceso que estaba ejecutando emacs (en primer plano)
*** Ctrl + c es la forma mas basica para interrumpir la ejecucion de cualquier proceso aunque no va a funcionar para todos los procesos, por esto existen formulas mas avanzadas que las iremos viendo mas adelante 

- esto fue un cierre abrupto del proceso y no es la unica manera de parar la ejecucion de un proceso
- hay otras formas de hacerlo: nosotros podriamos llegar, por ejemplo, a suspender o a usar la ejecucion de un proceso vvv 

- volvemos a ejecutar emacs (en primer plano) vvv
lionel@lionel-ubuntu:~$ emacs 

- en otra terminal corremos "ps x" y vemos que emacs se encuentra en un estado de Sleep 
lionel@lionel-ubuntu:~$ ps x
 PID TTY      STAT   TIME COMMAND
...
2835 pts/0    Sl+    0:00 emacs
*** que se encuentre en estado de Sleep no signiffica que el proceso se encuentre pausado, significa que esta esperacndo a que se genere algun tipo de evento (oir ejemplo, que el usuario presione alguna tecla, etc) y esto haria que el proceso pase de estar Sleep a estar en ejecucion

- de nuevo en la termian donde estamos ejecutando emacs, ejecutamos Ctrl + z
lionel@lionel-ubuntu:~$ emacs
^Z
[1]+  Stopped                 emacs
*** en la terminal donde se esta ejecutando emacs con Ctrl Z hemos parado el proceso emacs 
*** la interfaz grafica sigue ahi pero no podemos hacer nada en ella, y nos sale un confirm que nos dice "Emacs no esta respondiendo" con dos botones: "Interrumpir de manera forzosa" o "Esperar"
*** no puedo hacer nada en la interfaz grafica porque el proceso esta detenido, esta parado
*** tambien esta enviando al proceso a segundo plano (hablaremos de esto en la siguiente clase)

- dde nuevo en terminal2 tiramos un "ps x" para confirmar el estado de emacs
lionel@lionel-ubuntu:~$ ps x
 PID TTY      STAT   TIME COMMAND
...
3102 pts/0    Tl     0:00 emacs
*** en la otra terminal ahora vemos qeu emacs tiene una "T"
*** T quiere decir que el proceso esta parado y cuando esta parado no puede recibir ningun tipo de evento, no puede recibir nada

- mientras un proceso este detenido no va a consumir ningun tipo de recurso
- detener un proceso nos puede servir para, por ejemplo, detener un proceso que esta consumiendo muchos recursos en un momento dado, para liberar esos recursos y que los puedan consumir otros procesos ejecutandose en ese momento

- ahora vemos como reannudar el proceso detenido de emacs vvv
lionel@lionel-ubuntu:~$ bg %1
[1]+ emacs &
lionel@lionel-ubuntu:~$ 
*** con bg %1 reanudamos el proceso de emacs
*** ahora observamos que la terminal me deja seguir introduciendo comandos 
*** esto ocurre porque con Ctrl Z ademas de detener el proceso, lo enviamos a segundo plano, entonces ahora emacs se esta ejecutando en segundo plano dentro de esta terminal y por eso nosotros podemos interactuar con ella a pesar de que este soportando ese proceso

CONCLUSION:
- "ps" para ver informacion de todos los procesos ejecutandose en la terminal
- "ps x" para ver informacion de todos los procesos ejecutandose en el sistema
- "ps aux" simil a "ps x" pero da mas informacion aun de cada proceso
- "Ctrl + c" detiene  un proceso pero no va a servir para todos los procesos 
- "Ctrl + z" detiene un proceso y lo envia a segundo plano
- "bg %1" reanuda un proceso detenido (si el proceso fue detenido con "Ctrl + z", y por ende enviado a segundo plano, ahora cuando lo reanudamos, se estara ejecutando en segundo plano en la terminal en que se haya iniciado, entonces esto nos permitira seguir interactuando con esta terminal (por ejemplo, tirando mas comandos) mientras se sigue ejecutando en segundo plano el proceso de emacs)
- verificacion de estado del proceso emacs en las distintas instancias vvv 

lionel@lionel-ubuntu:~$ emacs       (STATE Sl+) * estado 1
lionel@lionel-ubuntu:~$ emacs
^Z
[1]+  Stopped                 emacs (STATE Tl)  * estado 2
lionel@lionel-ubuntu:~$ bg %1
[1]+ emacs &                        (STATE Sl)  * estado 3
lionel@lionel-ubuntu:~$ 

--------------------

68. Procesos en segundo plano

- cada vez que ejecutamos un comando en la shell como hemos visto hasta ahora, lo estamos ejecutando en un primer plano vvv

- ejecutamos emacs (proceso) en primer plano vvv
lionel@lionel-ubuntu:~$ emacs
| (cursor parpadeante)
*** vemos que nuestra shell queda bloqueada esperando a que se introduzca una combinacion de teclas o cualquier otro tipo de entrada de teclado 

- ademas de este primer plano (foreground) nosotros tenemos un segundo plano (background)
- es decir, podemos ejecutar los procesos de manera oculta y de una manera que van a ser inmunes a la entrada de teclado y tambien a combinaciones de teclas como por ejemplo "Ctrl + c" (APARENTEMENTE solo detiene procesos en primer plano) 
- esto evita que cada vez que ejecutemos un proceso como por ejemplo emacs, la shell quede bloqueada (que es lo que pasa cuando ejecutamos emacs en primer plano)

- aca vemos como ejecutar un proceso como emacs en segundo plano vvv 

lionel@lionel-ubuntu:~$ emacs &
[1] 3203
lionel@lionel-ubuntu:~$ ^C
lionel@lionel-ubuntu:~$ ^C
lionel@lionel-ubuntu:~$ 
*** en este ejemplo, "&" le indica a la shell de linux que tiene que ejecutar el proceso (en este caso emacs) en segundo plano 
*** comprobamos que la interfaz de emacs (la ventana del editor) se abre de la misma manera que ejecutandolo en primer plano 
*** como podemos observar, la shell donde estamos ejecutanto el proceso en segundo plano queda libre (podemos seguir interactuando con ella)
*** [1] es el identificador dentro de los procesos, de los trabajos, de los jobs que se estan ejecutando en segundo plano (identificador del proceso, entre los procesos corriendo en segundo plano)
*** 3203 es el PID del proceso
*** como observamos, ahora "Ctrl + c" no nos sirve para detener este proceso en segundo plano ("Ctrl + c" afecta solamente a lo que esta en primer plano)

lionel@lionel-ubuntu:~$ emacs &
[1] 3203
lionel@lionel-ubuntu:~$ jobs
[1]+  Running                 emacs &
*** "jobs" lista todos los procesos que se estan ejecutando en segundo plano 

lionel@lionel-ubuntu:~$ ps
    PID TTY          TIME CMD
   2359 pts/0    00:00:00 bash
   3203 pts/0    00:00:00 emacs
   3451 pts/0    00:00:00 ps
lionel@lionel-ubuntu:~$ 

- ejecuto pico en segundo plano para observar como se lista con "jobs" vvv
lionel@lionel-ubuntu:~$ pico &
[2] 3454
lionel@lionel-ubuntu:~$ jobs
[1]-  Running                 emacs &
[2]+  Stopped                 pico
lionel@lionel-ubuntu:~$ ps
    PID TTY          TIME CMD
   2359 pts/0    00:00:00 bash
   3443 pts/0    00:00:00 emacs
   3454 pts/0    00:00:00 pico
   3472 pts/0    00:00:00 ps

----------- 

lionel@lionel-ubuntu:~$ emacs           | ejecuto emacs en primer plano
^Z                                      | detengo el proceso y lo mando a segundo plano
[1]+  Stopped                 emacs     
lionel@lionel-ubuntu:~$ bg %1           | reanudo el proceso (ahora en segundo plano, ya que fue enviado al segundo plano por "Ctrl + z")
[1]+ emacs &                            

*** como vemos, "bg %1" es para reanudar procesos en segundo plano, siendo %1 el identificador de ese proceso o job 
*** [1]+ emacs & | observar que "bg %1" nos indica que ha puesto a ejecutar el job [1] en segundo plano (emacs &)

----------

- devolver a primer plano un proceso que esta en segundo plano vvv

lionel@lionel-ubuntu:~$ jobs
[2]+  Stopped                 pico
*** compruebo que tengo a pico en segundo plano

lionel@lionel-ubuntu:~$ fg %2
pico
*** con "fg" y pasandole el identificador del job que quiero llevar a primer plano (%2) envio al proceso a primer plano 
*** en este ejemplo, apenas ejecute "fg %2" se abrio el editor pico en la shell (como hubiese pasado si lo hubiese ejecutado en primer plano) 
*** fg hace referencia a foreground

- otro ejemplo con emacs vvv 

lionel@lionel-ubuntu:~$ emacs           | ejecuto emacs en primer plano
^Z                                      | detengo el proceso y lo envio a segundo plano
[1]+  Stopped                 emacs
lionel@lionel-ubuntu:~$ jobs            | verifico que emacs se encuentra detenido en segundo plano
[1]+  Stopped                 emacs
lionel@lionel-ubuntu:~$ bg %1           | reanudo la ejecucion en segundo plano del proceso
[1]+ emacs &
lionel@lionel-ubuntu:~$ jobs            | verifico que el proceso en segundo plano ahora se encuentra corriendo
[1]+  Running                 emacs &
lionel@lionel-ubuntu:~$ fg %1           | mando al proceso a primer plano
emacs
*** vemos que al estar ejecutandose emacs en primer plano, la shell se encuentra bloqueada permitiendo recibir entradas de teclado, por ejemplo "Ctrl + c" vvv

lionel@lionel-ubuntu:~$ fg %1
emacs
^Clionel@lionel-ubuntu:~$ 
*** al estar ejecutandose el proceso en primer plano, puedo interrumpirlo con "Ctrl + c" (comando que no me sirve para interrumpir procesos en segundo plano)

- en la proxima clase veremos como detener un proceso que se encuentra en segundo plano sin necesidad de tener que traerlo a primer plano para poder interrumpirlo con "Ctrl + c", tiene que ver con Señales (Signals)

--------------------

69. Señales (Signals)

- las señales van a ser una de las varias formas con las que el SO se va a poder comunicar con los programas 

- cuando ejecutabamos "Crl + c" o "Ctrl + z" en clases anteriores estabamos enviando una señal al programa que se estaba ejecutando en primer plano 

- cuando pulsabamos "Ctrl + c" estabamos enviando una señal que se denomina INT (abreviacion de "interrupcion")

- cuando pulsabamos "Ctrl + z" estabamos enviando una señal que se denomina TSTP (viene a ser algo como "parada de terminal")

- los programas mientras se ejecutan estan "escuchando" las señales que puedan recibir del SO y cuando la reciben realizan algun tipo de actuacion

- entonces las señales son un mecanismo de comunicacion entre el SO y los programas que hay en ejecucion 

----- 

¿Para que podemos utilizar nosotros las señales y como podemos mandarle señales a programas que tenemos ejecutandose?

- el comando que se utiliza para enviar señales es el comando kill

lionel@lionel-ubuntu:~$ man kill
KILL(1)     User Commands   KILL(1)
NAME
       kill - send a signal to a process
...

----- 

ALGUNOS EJEMPLOS DE SEÑALES QUE PODEMOS MANDARLE A PROCESOS EN SEGUNDO PLANO vvv

69.1 Pausar un proceso en segundo plano (señal TSTP, 20) | reanudar un proceso pausado en segundo plano (señal CONT, 18) vvv

- ya vimos que con "Ctrl. z", por detras, lo que hacemos es enviar una señal que se denomina TSTP a un proceso ejecutandose en primer plano, mediante la cual lo detenemos y lo enviamos a segundo plano
- cuando buscamos pausar o detener un proceso ejecutandose en segundo plano, debemos enviarle esta misma señal TSTP
- cuando el proceso esta en segundo plano, la señal TSTP que buscamos enviarle para detenerlo la podemos referenciar con la sigla en si misma o con el numero 20
- entonces ejecutamos en segundo plano emacs y lo pausamos o detenemos con el comando "kill -20 3220" (kill + referencia a la señal TSTP + PID del proceso ejecutandose en segundo plano)
- por otro lado vemos las formas para referenciar a la señal que reanuda un proceso en segundo plano que esta pausado (la señal CONTINUE, que se puede referenciar con CONT o con el nro 18) vvv

lionel@lionel-ubuntu:~$ emacs &
[1] 3220
lionel@lionel-ubuntu:~$ ps
    PID TTY          TIME CMD
   2359 pts/0    00:00:00 bash
   3220 pts/0    00:00:00 emacs
   3228 pts/0    00:00:00 ps
lionel@lionel-ubuntu:~$ kill -20 3220
lionel@lionel-ubuntu:~$ 
*** tambien podemos lograr lo mismo con "kill -TSTP 3220"

lionel@lionel-ubuntu:~$ emacs &             | ejecuto emacs en segundo plano
[1] 3425
lionel@lionel-ubuntu:~$ jobs                | emacs corriendo
[1]+  Running                 emacs &

lionel@lionel-ubuntu:~$ kill -TSTP 3425     | le mando la señal TSTP para pausarlo
lionel@lionel-ubuntu:~$ jobs                | emacs pausado
[1]+  Stopped                 emacs         

lionel@lionel-ubuntu:~$ kill -CONT 3425     | le mando la señal CONTINUE para hacerlo correr de nuevo
lionel@lionel-ubuntu:~$ jobs                | emacs corriendo
[1]+  Running                 emacs &

lionel@lionel-ubuntu:~$ kill -20 3425       | le mando la señal TSTP para pausarlo    
lionel@lionel-ubuntu:~$ jobs                | emacs pausado
[1]+  Stopped                 emacs
lionel@lionel-ubuntu:~$ kill -18 3425       | le mando la señal CONTINUE para hacerlo correr de nuevo
lionel@lionel-ubuntu:~$ jobs                | emacs corriendo
[1]+  Running                 emacs &

----- 

69.2 Señal STOP (19) vvv

- la señal STOP hace algo muy similar a lo que hace la señal TSTP 
- tambien podemos referenciar esta señal con el numero 19

lionel@lionel-ubuntu:~$ kill -STOP 3459

¿Cual es la diferencia entre la señal STOP y la señal TSTP?
- la diferencia es que TSTP es una señal que le llega al programa y que el programa gestiona como él considera, es decir, el programa puede recibir esa señal y decidir que quiere ignorarla, en cuyo caso no lo va a detener 
- la señal STOP lo que hace es decirle al Kernel que pare ese proceso, es decir, para forzozamente el proceso

----- 

69.3 Señal INT vvv

- INT es abreviatura de interrumpir (su numero asociado es el 2)
- INT es la que utilizabamos cuando mandabamos el comando "Ctrl c" para cerrar un proceso en primer plano 
- ejecutamos emacs en segundo plano, lo interrumpimos con la señal INT y comprobamos que el proceso ya no existe vvv

lionel@lionel-ubuntu:~$ emacs &
[1] 3500
lionel@lionel-ubuntu:~$ ps
    PID TTY          TIME CMD
   2359 pts/0    00:00:00 bash
   3500 pts/0    00:00:00 emacs
   3511 pts/0    00:00:00 ps
lionel@lionel-ubuntu:~$ kill -2 3500
lionel@lionel-ubuntu:~$ 
[1]+  Done                    emacs
lionel@lionel-ubuntu:~$ 
lionel@lionel-ubuntu:~$ 
lionel@lionel-ubuntu:~$ ps
    PID TTY          TIME CMD
   2359 pts/0    00:00:00 bash
   3518 pts/0    00:00:00 ps

----- 

69.4 Señal KILL vvv

- KILL tiene asignado el numero 9
- la señal KILL va a tener un comportamiento muy similar a la señal INT, es decir, va a interrumpir procesos en segundo plano, pero tiene una diferencia fundamental vvv 
- KILL se comporta como STOP, en el sentido que no va a permitir que el proceso la ignore (cosa que el proceso sí puede hacer con INT (en caso de señal de interrupcion) o con TSTP (en caso de señal de pausado) )

lionel@lionel-ubuntu:~$ emacs &
[1] 3561
lionel@lionel-ubuntu:~$ ps
    PID TTY          TIME CMD
   2359 pts/0    00:00:00 bash
   3561 pts/0    00:00:00 emacs
   3569 pts/0    00:00:00 ps
lionel@lionel-ubuntu:~$ kill -KILL 3561
lionel@lionel-ubuntu:~$ ps
    PID TTY          TIME CMD
   2359 pts/0    00:00:00 bash
   3574 pts/0    00:00:00 ps
[1]+  Killed                  emacs
lionel@lionel-ubuntu:~$ 

----- 

69.5 Señal TERM vvv

- TERM tiene asignado el numero 15
- TERM es la señal que utiliza kill por detras
- TERM entonces es otra señal para interrumpir forzozamente un programa 

lionel@lionel-ubuntu:~$ emacs &
[1] 3598
lionel@lionel-ubuntu:~$ kill -TERM 3598

----- 

69.6 Comando "kill -l"

- este comando lista todas las señales que tenemos disponibles dentro de linux

----- 

69.7 Comando "killall nombre_proceso"

- este comando manda la señal KILL en funcion del nombre del proceso y afectara a todos los procesos que compartan nombre y se esten ejecutando

lionel@lionel-ubuntu:~$ man killall
    killall - kill processes by name

lionel@lionel-ubuntu:~$ emacs &
[1] 3813
lionel@lionel-ubuntu:~$ emacs &
[2] 3821
lionel@lionel-ubuntu:~$ emacs &
[3] 3829

lionel@lionel-ubuntu:~$ jobs
[1]   Running                 emacs &
[2]-  Running                 emacs &
[3]+  Running                 emacs &
lionel@lionel-ubuntu:~$ ps
    PID TTY          TIME CMD
   2359 pts/0    00:00:00 bash
   3813 pts/0    00:00:00 emacs
   3821 pts/0    00:00:00 emacs
   3829 pts/0    00:00:00 emacs
   3863 pts/0    00:00:00 ps

lionel@lionel-ubuntu:~$ killall emacs
[1]   Exit 15                 emacs
[2]-  Exit 15                 emacs

lionel@lionel-ubuntu:~$ jobs
lionel@lionel-ubuntu:~$ ps
    PID TTY          TIME CMD
   2359 pts/0    00:00:00 bash
   3873 pts/0    00:00:00 ps

----- 

69.8 Las señales tienen permisos y privilegios 

- Nosotros no podemos mandar una señal a un programa si no somos superusuario o si no somos el usuario propietario de ese proceso

lionel@lionel-ubuntu:~$ emacs &
[1] 3972
lionel@lionel-ubuntu:~$ su testuser
Password: 
testuser@lionel-ubuntu:~$ kill -KILL 3972
bash: kill: (3972) - Operation not permitted
*** verificamos que testuser no puede interrumpir el proceso de lionel

lionel@lionel-ubuntu:~$ emacs &
[1] 4012
lionel@lionel-ubuntu:~$ sudo su
root@lionel-ubuntu:~# ps aux
... 
lionel      4012  2.0  1.7 768448 69216 pts/0    Sl   00:53   0:00 emacs

root@lionel-ubuntu:~# kill -KILL 4012
root@lionel-ubuntu:~# exit
lionel@lionel-ubuntu:~$ jobs
lionel@lionel-ubuntu:~$ 
*** verificamos que el usuario root puede interrumpir el proceso de lionel

----- 

CONCLUSION:
2)  INT  -> interrumpe de modo no forzoso un proceso (este puede ignorar la señal)
9)  KILL -> interrumpe de modo forzoso un proceso (este NO puede ignorar la señal)
15) TERM -> interrumpe de modo forzoso un proceso (este NO puede ignorar la señal)
18) CONT -> reanuda un proceso pausado
19) STOP -> pausa de modo forzoso un proceso (este NO puede ignorar la señal)
20) TSTP -> pausa de modo no forzoso un proceso (este puede ignorar la señal)
- solo el propietario de un proceso o el superadministrador pueden enviarle señales a los procesos

--------------------

70. Init, demonios y servicios

...