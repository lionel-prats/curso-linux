VIDEO 18 

El sistema de ficheros esta estructurado de manera jerarquica 
Las carpetas y los ficheros se distribuyen en forma de arbol
Tenemos una carpeta principal (carpeta o directorio raiz) y a partir de ahi empiezan a colgar el resto de directorios y archivos, con sus correspondientes subcarpetas y archivos

1) Instalamos la utilidad tree (no viene por defecto) para poder explorar el sistema de ficheros desde la terminal vvv 

sudo apt install tree

*** ejecute el comando 'tree /' (apuntando al directorio raiz) antes de la instalacion y comprobe que la utilidad no existe por default vvv

ejecucion -> tree / 

return -> Command 'tree' not found, but can be installed with:
sudo snap install tree # version 1.8.0+pkg-3fd6, or 
sudo apt install tree  # version 2.0.2-1 
See 'snap info tree' for additional versions.

*** una vez instalada la utilidad vvv 

tree / -> nos lista todo el arbol a partir de / 

tree -L 1 / -> lista la estructura a partir del 1er nivel (-L), solo un nivel (1), a partir del directorio raiz (/)

tree -L 2 /

----------------------------------------

VIDEO 19

pwd (print working directory) -> para obtener la ruta absoluta del directorio donde nos encontramos

* las rutas hacen referencia a un directorio o a un archivo dentro de nuestro sistema de ficheros

* return == /home/lionel -> cuando abrimos la shell por defecto nos situa (dentro del sistema de ficheros) en la carpeta /home, en el directorio de trabajo del usuario que está ejecutando la propia shell.
Cada uno de los usuarios del sistema Linux normalmente va a tener un directorio asociado dentro de /home.
Dentro de su carpeta, cada usuario tiene permisos plenos, fuera de ahi (por ejemplo en niveles superiores - dentro de /home y/o de otros directorios del mismo nivel, 1er nivel de /, no va a tener esos priviliegios)

ls -> directorios o archivos de la carpeta donde nos encontramos en el momento de la ejecucion del comando

ls -t -> los muestra ordenados por fecha de modificacion
ls -l -> info mas detallada del contenido 
ls -lh -> igual al anterior formateando el dato del peso para hacerlo mas legible
ls -a -> vemos tambien los archivos y directorios ocultos

cd / -> para pararme en la raiz del sistema de ficheros de Linux

cd /home/lionel -> para pararme en el directorio de trabajo del usuario con el que estoy en sesion en la shell

----- 

Dentro del sistema de fiicheros de Linux hay 2 tipos de rutas:
1) Rutas absolutas -> siempre parten desde la raiz (/) -> cd /home/lionel/Desktop
2) Rutas relativas ->

. .. -> son 2 archivos ocultos que siempre estan dentro de un directorio, aunque aparentemente este vacio 

. -> hace referencia al directorio actual (una especie de enlace al directorio actual)
.. -> hace referencia al directorio anterior

cd -> asi solo sirve para pararnos en nuestro directorio de trabajo sea donde sea que nos encontremos en el sistema de ficheros de Linux
cd ~ -> hace lo mismo que cd 
cd - -> vuelve al lugar inmediatamente anterior donde estabamos parados dentro del directorio de ficheros

----------------------------------------

VIDEO 20

Ficheros y directorios ocultos -> por norma general, van a ser archivos y directorios de configuracion (suelen tener informacion de configuracion)

en /home/lionel 

.bash_history -> todo el historial de comandos que nosotros vamos ejecutando dentro de la shell 
.bashrc -> fichero de configuracion de nuestra shell
.profile -> nuestra configuracion del perfil

*** Los ficheros en la shell no tienen extension 
*** El propio SO Linux no utiliza las extensiones para nada

----------------------------------------

VIDEO 21 

mkdir test -> creo una nueva carpeta en el lugar donde estoy parado

*** Dentro del SO Linux (al igual que en Windows) tenemos editores de texto que vienen por defecto (aplicaciones que estan dentro de nuestro SO).

*** En Linux tenemos un monton de editores que podemos usar en la shell y que vienen por defecto en el SO (uno de los mas populares es pico) 

Algunos editores de texto por default:
- pico 
- nano 
- vi (tuve que forzar el cierre de la terminal porque no me funciono ni q ni q+Enter)
- emacs (no viene por defecto - ver comando en instalaciones.txt)

emacs --help -> para buscar en la consola info acerca del editor
emacs -nw -> para usar el editor desde la consola (omitimos la interfaz grafica por default)
*** pude salir con Ctrl+x/Ctrl+c

pico fichero_de_prueba.txt -> para abrir un archivo existente desde la consola y editarlo (con el editor nativo pico) 

----------------------------------------

VIDEO 22

- EL SO no va a interpretar las extensiones para absolutamente nada

file Desktop -> nos indica si se trata de un directorio o fichero (y si es fichero, de que tipo: datos, imagenes, etc)

cat auth.log -> imprime por consola el contenido de un fichero o archivo

lionel@lionel-ubuntu:/var/log$ more auth.log
-> nos sirve para contenidos extensos de ficheros -> nos muestra desde el inicio del contenido y solo lo que cabe en la pantalla de la shell, luego podemos seguir bajando con Enter 

lionel@lionel-ubuntu:/var/log$ less auth.log
*** es la mejora de more (pagina el contenido del fichero)
*** tab "h" -> nos muestra el listado de acciones que podemos utilizar dentro de less (tab "q" para salir de este menu y volver atras) 
*** tab "space" -> nos muestra la pagina siguiente 
*** tab "b" -> pnos muestra la pagina anterior 
*** tab "/" + string + Enter -> para buscar el substring pasado como argumento en la pagina actual del contenido del texto (tab "n" para ver mas coincidencias en paginas siguientes)
*** tab "g" -> para ir al inicio del fichero 
*** tab "shift" + "g" -> para ir al final del fichero
*** ↓↑ -> para movernos para arriba o para abajo de a un renglon
*** tab "q" -> para salir de la utilidad

----------------------------------------

VIDEO 23 

cp nombre_fichero_copiado nombre_fichero_resultante -> duplicar un fichero con nombre nuevo (si ya existe un fichero con el nombre del segundo argumento, lo reescribe) 

cp -i fichero fichero2 -> la consola genera una validacion si detecta que el fichero que quiero crear ya existe (si el archivo existe y en la validacion tipeo "y" se va a reescribir el archivo detectado)

cp fichero fichero2 fichero3 directorio1/ -> copio los 3 achivos en una subcarpeta del espacio donde estoy parado

cp -r directorio1/ directorio2/ -> creo la carpeta directorio2, copia de directorio1 (el parametro -r viene de recursivo)

mv fichero_mover.txt directorio1 -> para mover un fichero desde el espacio donde estoy parado hata el espacio definido en el segundo parametro

mv directorio2/ directorio1/ -> mover un directorio dentro de otro

mv directorio2/ nombrenuevo/ -> renombrar un directorio (si ya existe nombrenuevo/, directorio2/ se moverá a nombrenuevo/) 

mv fichero ficheroloco -> renombar un archivo (si ya exsite ficheroloco, su contenido va a ser reescrito con el contenido de fichero, y el archivo de fichero se va a borrar)

mv -i fichero ficheroloco -> aplico una validacion de seguridad

rm fichero -> eliminar un archivo de forma permanente

rm -r directorio -> eliminar un directorio de forma permanente (-r == recursivo, significa que se va a borrar el directorio y todo lo que pueda tener dentro)

touch ficherovacio -> para crear un fichero vacio

rm -rf piluso -> para forzar el borrado sin importar nada (sirve para archivos y directorios)

----------------------------------------

VIDEO 24 

find -> comando para buscar archivos en todo el sistema de archivos de linux 
find /var/log /home/lionel -name auth.log -> busco la ruta completa de un archivo por nombre dentro de las dos rutas definidas de forma recursiva, es decir, dentro de los dos espacios definidos y dentro de los subdirectorios que puedan haber

find /var -name auth.log 2> /dev/null -> para eliminar los prompt de los avisos de acceso denegados que puedan aparecer (esto es, cuando encuentre algo relacionado a mi busqueda, pero que a lo que mi usuario no tenga acceso)

find /var -name auth.log -ls 2> /dev/null -> ++ info sobre el archivo ademas de la ruta completa

find . -name auth.log -> "busca en mi directorio actual y en sus subdirectorios un archivo que se llame auth.log"

find /var/log -name '*.log' -> busca en el directorio indicado y en sus subdirectorios un archivo que termine en .log

*** una carpeta es un tipo de archivo especial 

find / -name server-202 -type d -> buscar carpetas en todo el arbol de archivos de linux
find / -name curso-linux -type d 2> /dev/null

buscar una carpeta o archivo creado por un usuario en particular 
find /var/log -name "*" -user lionel
find /var/log -name "*" -user lionel 2> /dev/null 

find /home/lionel -name "*" -user lionel 2> /dev/null 

----------------------------------------

EJERCICIO: Utiliza el comando find para buscar los siguientes ficheros dentro de Linux.

Preguntas de esta tarea

1) Busca la ruta donde se encuentra el comando externo ls utilizando find. Asegúrate de eliminar los mensajes de acceso denegado que produzca el comando.

find / -name ls 2> /dev/null

2) Busca directorios de configuración del programa firefox que viene instalado por defecto en Ubuntu. El nombre de los directorios debe ser firefox (igual que el programa).

find / -name "*firefox*" -type d 2> /dev/null

3) Busca el usuario propietario del fichero shadow que se encuentra en algún lugar del sistema de ficheros de Linux excluyendo aquellos ficheros shadow que se encuentren dentro de la ruta /snap.

find / -name shadow ! -path "/snap/*" -ls 2> /dev/null
3.1) El usuario propietario del fichero es root (hablaremos más sobre esto en la sección de permisos).
3.2) El comando se divide en las siguientes partes:
3.3) find / -name shadow: Buscamos el fichero shadow en el directorio raíz
3.4) ! -path "/snap/*": Excluimos todos los resultados cuya ruta comience por /snap
3.5) -ls: Mostramos información avanzada sobre el fichero
3.6) 2> /dev/null: Eliminamos los errores de permiso denegado.

----------------------------------------

VIDEO 25

Sistema de archivos/ficheros de Linux -> Estructura de carpetas/directorios creada por defecto en Linux vvv 

lionel@lionel-ubuntu:~$ tree / -L 1 -> primer nuivel de la jerarquia
/
├── bin -> usr/bin
├── boot
├── cdrom
├── dev
├── etc
├── home
├── lib -> usr/lib
├── lib32 -> usr/lib32
├── lib64 -> usr/lib64
├── libx32 -> usr/libx32
├── lost+found
├── media
├── mnt
├── opt
├── proc
├── root
├── run
├── sbin -> usr/sbin
├── snap
├── srv
├── swapfile
├── sys
├── tmp
├── usr
└── var

1) /bin -> usr/bin
    se utilizaba historicamente para almacenar binarios de algunos comandos esenciales del sistema operativo que debian estar disponibles incluso para cosas como por ejemplo levantar el sistema, arrancar el sistema o repararlo.
    A dia de hoy, este directorio ya no existe propiamente, entonces realmente es un enlace simbolico (tambien se suele llamar soft link)
    Seria lo mismo que un acceso directo en Windows, es decir, es un enlace que va a apuntar a otra carpeta dentro de nuestro sistema de ficheros, /usr/bin
    A dia de hoy, todos esos binarios esenciales que almacenaba, estan dentro de la carpeta /user/bin
2) /boot
    continene los archivos que se utilizan para arrancar el SO
    concretamente va a contener archivos del Kernel de Linux (tambien denominados archivos del cargador de arranque) y dependiendo del software (distribucion (?)) que utilizemos para cargar el arranque seran los ficheros y directorios que contendra (del Kernel (?))
    Linux utiliza un cargador de arranque que se llama grub (cd /boot/grub)
3) /cdrom
   esta ahi por razones historicas
   hoy practicamente no utilizamos cdrom, tenemos cosas en la nube, tenemos USBs 
4) /dev
    aqui lo que tenemos son diferentes interfaces tanto para leer como para escribir en diferentes dispositivos
    tenemos incluso interfaces para escribir por pantalla en la propia terminal
    estas interfaces son una especie de ficheros especiales (lo veremos mas adelante)
5) /etc
    va a contener la informacion de configuracion de nuestro SO
6) /home
    dentro se van a crear las carpetas de trabajo de cada uno de los usuarios que tenemos en el sistema donde tendra privilegios para escribir, leer ficheros y hacer todo lo que quiera
    es la carpeta personal de cada usuario de Linux
7) /lib -> usr/lib
8) /lib32 -> usr/lib32
9) /lib64 -> usr/lib64
10) /libx32 -> usr/libx32
    todos enlaces simbolicos a subdirectorios de /usr 
    estos directorios /usr/* van a contener aquellas librerias que van a requerir los diferentes programas que tenemos dentro de nuestro SO para su funcionamiento
    /lib es otra carpeta gestionada por el SO, aunque nosotros aqui si que podriamos llegar a introducir algunas librerias si la requiriese alguno de nuestros programas
11) /lost+found
    esta carpeta tiene que ver con una utilidad que es fsck 

    fsck -> utilidad que utilizamos cuando queremos recuperar parte del sistema de ficheros que por alguna razon ha quedado inconsistente o dañado

    por ejemplo, estamos trabajano en un archivo, se corta la luz y no llegamos a guardar cambios, podemos usar este tipo de comandos para tratar de recuperar la informacion que se haya podido perder durante esta interrupcion del SO

    esta informacion que se recupera, normalmente queda almacenada en /lost+found

12) /media
    es muy similar a lo que vimos con /cdrom
    va a ser la carpeta donde en teoria vamos a montar dispositivos externos
13) /mnt
    es otro punto de montaje (mnt viene de "mount")
    esto esta creado para que nosotros montemos tambien dispositivos externos, pero mas bien esta pensado para que montemos esos dispositivos de manera manual
    es como para contar con un directorio de montaje en el que si tu tienes que montar algo de manera manual utilizando una serie de utilidades que ya veremos mas adelante, utilizes este directorio 
    es un poco redundante con /media y /cdrom 
14) /opt
    opt es la abreviacion de "optional"
    se usaba antiguamente cuando te servian el SO, para alojar programas o modulos opcionales
    hoy por default esta vacio y rara vez lo vamos a utilizar para meter algo 

15) /proc
    *** este directorio esta administrado por el sistema, no debemos tocar nada de lo que hay dentro
    *** si tiramos un ls en /proc vamos a obtener una interfaz con el Kernel
    *** aqui vamos a obtener un monton de informacion sobre como esta funcionando el Kernel y los dispositivos hardware que tenemos en nuestra maquina
    *** tenemos por ejemplo ficheros como filesystems que nos da informacion sobre los sistemas de ficheros que tenemos cargados 
    *** meminfo de informacion sobre la memoria
    *** tenemos varios ficheros que nos van a dar informacion sobre el hardware y el funcionamiento del kernel
    *** tenemos tambien cpuinfo sobre la cpu 
    *** tenemos tambien directorios con diferentes numeros 
    *** estos numeros son PIDs, pero basicamente son identificadores de procesos 
    *** cada uno de los procesos que tenemos tiene un directorio asociado dentro de /proc que contiene informacion sobre el estado en el que se encuentra en este momento, como se ha ejecutado, etc.
    *** lo que vemos dentro de /proc no es un sistema de ficheros propiamente dicho sino que se suele llamar sistema de ficheros virtual porque esta como creado sobre la marcha, en tiempo de ejecucion 

    *** si hacemos un ls -la /proc comprobamos que la mayoria de los los archivos y directorios continenen 0 bits

    lionel@lionel-ubuntu:/proc$ echo $$
    2360
    *** esto me da el PID del proceso actual, que seria la propia shell, que es un proceso dentro de nuestro SO

    lionel@lionel-ubuntu:/proc$ cd 2360
    *** entro al directorio del proceso

    lionel@lionel-ubuntu:/proc/2360$ ls -la .
    *** comprobamos que todos los archivos que figuran dentro tienen 0 bits 

    *** por eso es que se llama a lo que hay dentro de /proc un sistema de ficheros virtual, no es propiamente un sistema de ficheros

    lionel@lionel-ubuntu:/proc/2360$ less status
    *** con este comando podemos ver el estado de nuestro proceso (del 2360, status es un fichero dentro de /proc/2360) 

16) /root
    es la carpeta de trabajo del usuario root
17) /run
    aqui van a guardar informacion algunos programas que inician muy rapido cuando nosotros arrancamos el SO 
    van a almacenar informacion de runtime, informacion en tiempo de ejecucion
18) /sbin -> usr/sbin
    enlace simbolico a /usr/sbin 
    es muy similar a /usr/bin, donde tenemos binarios esenciales del sistema, pero aqui vamos a tener otro tipo de binarios que normalmente estan reservados para tareas super vitales, super esenciales dentro del SO y que por norma general solamente van a poder ejecutarlos usuarios que tengan privilegios de administracion, que sean superusuarios
19) /snap
    es un gestor de paquetes 
    es para intalar programas externos 
    cuando instalamos paquetes utilizando este gestor se van a instalar en esta ruta
20) /srv
    contiene ciertos datos de servicios, normalmente informacion que nosotros estamos sirviendo hacia afuera
    cuando nosotros instalamos ciertos softwares, como por ejemplo FTP, o cosas que esten sirviendo informacion, es posible que se cree aqui un directorio con el nombre de ese software o de ese protocolo (por ejemplo "/ftp") y tenga aqui cierta informacion que estemos sirviendo 
21) /swapfile
    hace el swap de la memoria RAM a disco para no saturar la memoria RAM 
    cuando un proceso tiene mucha informacion almacenada comienza a paginar, comienza a tomar informacion que esta en memoria RAM y la empieza a volcar a disco
    concretamente la vuelca a este fichero /swapfile
    es un fichero grande (ls -lah 2.1G) donde el SO va haciendo swaping constantemente desde memoria RAM a disco
22) /sys
    otro directorio propio del SO
    este directorio nos sirve tambien de interfaz con el Kernel
    aqui tenemos algunos ficheros con parametros de configuracion que incluso podemos llegar a modificar para dar algunas instrucciones al kernel: cambiar ciertos comportamientos, etc. (esto representa una interfaz, una manera de transmitir informacion a ciertos procesos que funcionan dentro del kernel para que realizen algunas tareas)
    aqui rara vez vamos a modificar ficheros, y cuando lo hagamos debemos tener muy claro lo que estamos haciendo
23) /tmp
    directorio temporal pensado para que el usuario almacene en el cualquier tipo de dato que simplemente lo este descargando 
    en muchas ocasiones este directorio se borra cuando reiniciamos el equipo
    todos los usuarios tienen permisos completos sobre este directorio
24) /usr
    es el directorio mas grande de todos los que hemos visto y el mas grande dentro de la jerarquia de Linux 
    tendremos todo lo que son programas, configuraciones, librerias, todo lo que es propio de los usuarios 
25) /var
aqui tenemos datos que cambian con frecuencia

----------------------------------------

VIDEO 26

emacs /etc/passwd -> para leer un fichero con informacion de todos los usuarios del nuestra maquina Linux con el editor instalado emacs

Ctrl + z -> envia el proceso anterior a segundo plano

ps -> podemos observar el PID, que es un identificador de procesos vvv
PID   TTY       TIME CMD
2340  pts/0 00:00:00 bash
14080 pts/0 00:00:01 emacs
14151 pts/0 00:00:00 ps

prlimit --as=1000 --pid 14080
-> con esto estamos limitando la cantidad de memoria RAM que puede consumir este proceso emacs (ya que en comando incluimos el identificador PID)
-> cuando llegue al limite (1000 == 1mb) emacs va a tratar de volcar la informacion que no puede mantener en memoria RAM a disco (al fichero swapfile)

fg -> con este comando vuelvo a traer el proceso emacs a primer plano

sudo cp /swapfile /home/lionel/Desktop/
-> sudo nos permite elevar prvilegios
-> con este comando hice una copia del fichero /swapfile en el escritorio de mi maquina Linux 

sudo chmod 755 /home/lionel/Desktop/swapfile 
-> con este comando le doy suficientes permisos al fichero en mi Desktop para poder cerrar la shell 

cat /etc/passwd -> cat imprime el contenido de un archivo en la terminal

*** el ejercicio consiste en hacer un copy paste del swapfile desde mi Desktop en la VM (SO Ubuntu) a mi maquina host (W10), pero no me funcionó
*** Luego, en la maquina host instala Autopsy (https://www.autopsy.com/) para hacer busquedas en el swapfile copypasteado desde la VM 

----------------------------------------

VIDEO 28 - Inodos
en la raiz del arbol de ficheros, con cd home/lionel me paro en el home de mi usuario

Los datos relacionados a un directorio o fichero, como ser propietario, permisos, fecha de creacion, tamaño, etc, se denominan METADATOS
Todos estos metadatos tienen que estar almacenados en alguna parte 
La estructura que va a almacenar esta informacion se denomina INODO
Todos los ficheros y directorios que tengamos dentro de nuestro sistema de ficheros en Linux van a tener asociado un INODO
Estos INODOS van a contener la informacion de contexto, los metadatos, asociados a los archivos o directorios
Cada inodo va a tener un identificador, que va a ser el que va a usar el SO por detras para gestionar todos los ficheros del sistema de ficheros

df -i 
-> nos devuelve informacion de todos los sistemas de ficheros existentes en nuestra VM
-> en Linux podemos tener varios sistemas de ficheros
-> el principal es el que esta montado en la raiz (Mounted on), que es el sistema con el que venimos trabajando vvv
Filesystem   Inodes   IUsed    Ifree IUse%   Mounted on 
/dev/sda3   1277952  225526 10524426   18%   /

ls -i fichero.txt -> para acceder al nro de inodo de fichero.txt

stat fichero.txt -> para ver info del fichero que nos proporciona su inodo (identificador = 529482)

sudo debugfs -R "stat <529482>" /dev/sda3
-> con sudo ejecutamos un comando con privilegios de administrador
-> nos muestra la misma info que el comando anterior pero presentada de otra manera
-> 529482 es el indo (identificador unico) del fichero

----------------------------------------

VIDEO 28 - Inodos (REPASO)

df -i 
-> nos devuelve informacion de todos los sistemas de ficheros existentes en nuestro SO 
-> en Linux podemos tener varios sistemas de ficheros 
-> el principar es el que esta montado en la raiz (Mounted on == /)   
Filesystem      Inodes  IUsed   IFree IUse% Mounted on
/dev/sda3      1277952 228000 1049952   18% /

ls -i fichero.txt -> para acceder al nro de inodo de un fichero en particular

stat fichero.txt -> para visualizar los metadatos de un fichero en particular

sudo debugfs -R "stat <529047>" /dev/sda3
-> nos muestra la misma info que el comando anterior pero presentada de otra manera

sudo debugfs -R "stat <12>" /dev/sda3
-> para ver los metadatos del archivo swapfile en la raiz de nuesto SO

--------------------

VIDEO 29 - Dentries

Dentries -> Directory Entries

ls -lid curso-linux -> para acceder al inodo de un directorio 

stat curso-linux

ls -lia /home/lionel

--------------------

VIDEO 30 - Enlaces simbólicos (Soft Links)

ls -li / -> para acceder a los inodos e informacion de todos los directorios y archivos de un directorio

ls -lid / -> para acceder al inodo e informacion de un directorio

Ctrl + r 
-> para buscar el substring mas reciente en el historial de comandos
-> con mas Ctrl + r me voy moviendo hacia atras en los comandos que contengan ese substring

pwd -> para saber la ubicacion en la que estoy parado dentro del sistema de ficheros de Linux 

PRACTICA: crear enlace simbolico de un fichero vvv 
1) En /home/lionel/Desktop creo el fichero "fichero_escritorio.txt"
2) Retrocedo un nivel y desde /home/lionel creo un enlace simbolico al archivo creado en 1) vvv
ln -s Desktop/fichero_escritorio.txt fich_sim 
-> -s == soft link
-> enlace simbolico creado usando una ruta relativa (Desktop/fichero)

3) Desde /home/lionel tiro un cat fich_sim y compruebo que accedo al contenido de fichero_escritorio.txt, por lo tanto el enlace simbolico funciona

* tambien se puede crear un enlace sombolico con rutas absolutas vvv
ln -s /home/lionel/Desktop/fichero_enlazado enlace

* tambien se pueden crear accesos simbolicos a directorios

--------------------

VIDEO 31 - Enlaces duros (Hard Links)

- Los Hard Links son solo accesos o enlaces para ficheros 

- un hard link se crea con la utilidad ln (igual que los soft links)

info ln -> para ver documentacion de una utilidad (ln es una utilidad)

lionel@lionel-ubuntu:~$ ln Desktop/fichero_con_hard_link.txt hard_link
*** creo el hardlink "hard_link" al archivo Desktop/fichero_con_hard_link.txt

- El nro de inodo de un hardlink coincide con el nro de inodo del archivo al que hace referencia 
*** ls -li para acceder a los nros de inodos de ficheros y directorios vvv 

lionel@lionel-ubuntu:~$ cat Desktop/fichero_enlazado hardlink enlace
fichero de prueba

fichero de prueba

fichero de prueba

lionel@lionel-ubuntu:~$ ls -li Desktop/fichero_enlazado hardlink enlace
525321 -rw-rw-r-- 2 lionel lionel 19 feb 19 22:13 Desktop/fichero_enlazado
525277 lrwxrwxrwx 1 lionel lionel 37 feb 19 22:14 enlace -> /home/lionel/Desktop/fichero_enlazado
525321 -rw-rw-r-- 2 lionel lionel 19 feb 19 22:13 hardlink
*** como se ve, un softlink tiene su propio inodo, en cambio un hardlink comparte el inodo con su referencia
*** esto quiere decir que un hardlink es una referencia al mismo inodo del fichero al que esta enlazado 
*** a efectos practicos, un hardlink es como si fuese el mismo fichero al que esta enlazado 

- luego, el profesor demuestra que, luego de eliminar el fichero original con rm, el hardlink sigue funcionando y se puede acceder al contenido del fichero eliminado (en la misma situacion, un softlink se rompe)
- esto es porque el hardlink sigue referenciando al nro de inodo original del fichero, y en ese inodo aparecen los bloques donde esa informacion del fichero estaba en memoria

.  -> hardlink al directorio actual (mismo inodo)
.. -> hardlink al directorio padre de un directorio (mismo inodo)

--------------------

VIDEO 32 - Wildcards

Los wildcards son un conjunto de simbolos que nos van a permitir referenciar un grupo de ficheros utilizando patrones en sus nombres 

1) * == cualquier caracter y cualquier cantidad de caracteres

lionel@lionel-ubuntu:~/Desktop/curso-linux$ cat pruebas/fichero*
contenido del fichero1.txt
contenido del fichero2.txt
contenido del fichero3.txt
contenido del fichero4.txt
contenido del fichero5.txt

lionel@lionel-ubuntu:~$ ls -l D*
Desktop:
...
Documents:
...
Downloads:
...

lionel@lionel-ubuntu:~$ ls -d D*
Desktop  Documents  Downloads

2) ? == cualquier caracter, pero unicamente un caracter

lionel@lionel-ubuntu:~$ cat Desktop/curso-linux/pruebas/fichero?.txt
contenido del fichero1.txt
contenido del fichero2.txt
contenido del fichero3.txt
contenido del fichero4.txt
contenido del fichero5.txt

3) 
lionel@lionel-ubuntu:~$ cat Desktop/curso-linux/pruebas/fichero[12399].txt
contenido del fichero1.txt
contenido del fichero2.txt
contenido del fichero3.txt
-- NO fichero4.txt
-- NO fichero5.txt
-- NO fichero99.txt
lionel@lionel-ubuntu:~$ 

lionel@lionel-ubuntu:~$ cat Desktop/curso-linux/pruebas/fichero[!123].txt
contenido del fichero4.txt
contenido del fichero5.txt
-- NO fichero1.txt
-- NO fichero2.txt
-- NO fichero3.txt
-- NO fichero99.txt

4)
lionel@lionel-ubuntu:~$ cat Desktop/curso-linux/pruebas/fichero[[:digit:]].txt
contenido del fichero1.txt
contenido del fichero2.txt
contenido del fichero3.txt
contenido del fichero4.txt
contenido del fichero5.txt

*** class == conjunto de caracteres determinado vvv
digit
alpha 
alnum
upper
lower

lionel@lionel-ubuntu:~$ ls -ld [[:upper:]]*
drwxr-xr-x 4 lionel lionel 4096 feb 24 00:11 Desktop
drwxr-xr-x 2 lionel lionel 4096 sep  5 15:06 Documents
drwxr-xr-x 2 lionel lionel 4096 feb 24 00:07 Downloads
drwxr-xr-x 2 lionel lionel 4096 sep  3 22:17 Music
drwxr-xr-x 2 lionel lionel 4096 sep  3 22:17 Pictures
drwxr-xr-x 2 lionel lionel 4096 sep  3 22:17 Public
drwxr-xr-x 2 lionel lionel 4096 sep  3 22:17 Templates
drwxrwxr-x 2 lionel lionel 4096 sep  5 12:53 Test
drwxr-xr-x 2 lionel lionel 4096 sep  3 22:17 Videos
*** todos los nombres de directorios que empiezen con una letra mayuscula

lionel@lionel-ubuntu:~$ cat fichero[![:digit:]].txt
contenido del ficheroC

lionel@lionel-ubuntu:~$ cat fichero[[:digit:]].txt
Contenido del fichero 7

--------------------

TAREA 32 - Wildcards

Utiliza los wildcards presentados en la sección anterior para realizar las siguientes búsquedas de ficheros y directorios.

Preguntas de esta tarea

Busca todos los ficheros que se encuentran en /usr/bin y terminan por un número.
lionel@lionel-ubuntu:~$ ls -l /usr/bin/*[[:digit:]]
lionel@lionel-ubuntu:~$ find /usr/bin/ -maxdepth 1 -name *[[:digit:]] 2> /dev/null
SOLUCION -> find /usr/bin -name '*[[:digit:]]'

Busca todos los ficheros en el sistema de ficheros de Linux que contenga dos caracteres _ en el nombre y terminen en .txt.
lionel@lionel-ubuntu:~$ find / -name *_*_*.txt 2> /dev/null
SOLUCION -> find / -name '*_*_*.txt' 2> /dev/null
            
Busca todos los ficheros en /var/log que no terminen en .log
lionel@lionel-ubuntu:~$ ls -l /var/log/*.log
lionel@lionel-ubuntu:~$ find /var/log/ -maxdepth 1 -name *.log 2> /dev/null
lionel@lionel-ubuntu:~$ find /var/log/ -name *[!'.log'] 2> /dev/null
SOLUCION -> find /var/log -name '*[!.log]' 2> /dev/null
            find /var/log/ -name '*[!.log]' 2> /dev/null

--------------------

VIDEO 33 - Shell Expansions 

lionel@lionel-ubuntu:~$ type echo
echo is a shell builtin
lionel@lionel-ubuntu:~$ 

*** el comando echo viene implementado en la shell por defecto
*** imprime por pantalla el texto que le proporcionemos como argumento
*** realmente, lo que hace echo es redirigir el argumento recibido a lo que se denomina standard output, que es un fichero especial del que ya hablaremos

~ -> referencia nuestro directorio de trabajo, nuestro directorio /home

lionel@lionel-ubuntu:~$ echo ~
/home/lionel
*** la shell expande "~" a "/home/lionel"

lionel@lionel-ubuntu:~$ echo /*/log
/dev/log /run/log /var/log
*** listo todos los directorios dentro de la raiz, que contengan un subdirectorio /log

lionel@lionel-ubuntu:/$ echo $((2 + 2))
4

lionel@lionel-ubuntu:/$ echo $((2 ** 3))
8

lionel@lionel-ubuntu:~$ cat fichero$((1+1))*
contenido fichero2.txt

Brace expansins ("{", "}")

lionel@lionel-ubuntu:~$ echo fichero{1,2,3,Katopodis}.txt
fichero1.txt fichero2.txt fichero3.txt ficheroKatopodis.txt

lionel@lionel-ubuntu:~$ echo fichero{10..15}.txt
fichero10.txt fichero11.txt fichero12.txt fichero13.txt fichero14.txt fichero15.txt

lionel@lionel-ubuntu:~$ mkdir dir{1..5}
*** creo en simultaneo /dir1, /dir2, /dir3, /dir4 y /dir5

lionel@lionel-ubuntu:~$ echo {A..z}
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [  ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z

lionel@lionel-ubuntu:~$ echo {z..A}
z y x w v u t s r q p o n m l k j i h g f e d c b a ` _ ^ ]  [ Z Y X W V U T S R Q P O N M L K J I H G F E D C B A

lionel@lionel-ubuntu:~$ echo texto{A{1,2},B{3,4}}final
textoA1final textoA2final textoB3final textoB4final

lionel@lionel-ubuntu:~$ mkdir logs
lionel@lionel-ubuntu:~$ cd logs/

lionel@lionel-ubuntu:~/logs$ mkdir {2024..2030}-{01..12}
*** creé carpetas desde 2024-01 hasta 2030-12 (84 carpetas)

lionel@lionel-ubuntu:~/logs$ rmdir {2024..2030}-{01..12}
*** borré las 84 carpetas anteriores

--------------------

VIDEO 34 - Command Substitution 

lionel@lionel-ubuntu:~$ which cat
/usr/bin/cat
* which  returns the pathnames of the files (or links) which would be executed in the current environment (documentacion obtenida con info which)

lionel@lionel-ubuntu:~$ type cat
cat is /usr/bin/cat

- Buscamos pasar la salida de un ejecutable como parametro de entrada a otro ejecutable vvv

lionel@lionel-ubuntu:~$ ls -la which cat
ls: cannot access 'which': No such file or directory
ls: cannot access 'cat': No such file or directory
*** aca vemos que la terminal interpreta a which como el nombre de un fichero o directorio, y al no encontrarlo tira error

lionel@lionel-ubuntu:~$ ls -al $(which cat)
-rwxr-xr-x 1 root root 35280 feb  7  2022 /usr/bin/cat
*** con esta expansion de la shell (command substitution), le pasamos la salida de la ejecucion del ejecutable which como parametro de entrada a la ejecucion del comando ls 

lionel@lionel-ubuntu:~$ ls -al /usr/bin/cat
-rwxr-xr-x 1 root root 35280 feb  7  2022 /usr/bin/cat
*** en este caso, el comando anterior es equivalente a este
*** el comando cat es un binario 

lionel@lionel-ubuntu:~$ python3
Python 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 

*** se abre el interprete de Python 
*** ENTIENDO que Python viene instalado por default en Ubuntu  (?)
*** exit() para salir del interprete de python

lionel@lionel-ubuntu:~$ python3 -c 'print("Hola mundo")'
Hola mundo
*** se va a ejecutar el codigo print("Hola mundo") interpretado como codigo en python y la salida va a mostrarse en el stdout

lionel@lionel-ubuntu:~$ echo $(python3 -c 'print("Hola mundo")')
Hola mundo

*** en versiones antiguas de bash, que es el tipo de shell que estamos utilizando ahora, en lugar de usar el patron $() para indicar un command substitution, se utilizaban las ``
*** sigue habiendo retrocompatibilidad vvv

lionel@lionel-ubuntu:~$ ls -la `which cat`
-rwxr-xr-x 1 root root 35280 feb  7  2022 /usr/bin/cat
lionel@lionel-ubuntu:~$ ls -la $(which cat)
-rwxr-xr-x 1 root root 35280 feb  7  2022 /usr/bin/cat

--------------------

VIDEO 35 - Comillas en la Shell de Linux

todo lo que introduzcamos entre "" dentro de la shell de Linux va a provocar que pierdan su significado todos los caracteres especiales, menos 3 vvv
- $
- \
- `

Comillas dobles vvv 
-------------------

lionel@lionel-ubuntu:~$ echo fichero*
fichero1.txt fichero2.txt ficheroC.txt
*** el wild card * es interpretado correctamente

lionel@lionel-ubuntu:~$ echo "fichero*"
fichero*
*** en este caso, * no es interpretado como un wildcard por la shell

lionel@lionel-ubuntu:~$ echo "La ruta de cat es: $(which cat)"
La ruta de cat es: /usr/bin/cat
*** el command substitution $() se sigue interpretando correctamente

lionel@lionel-ubuntu:~$ echo "La ruta de ls es: `which ls`"
La ruta de ls es: /usr/bin/ls
*** el command substitution `` se sigue interpretando correctamente

Comillas simples vvv 
--------------------

- Las '' sirven para eliminar el comportamiento de todos los caracteres especiales que hay en la shell, incluidos $ \ ` vvv 

lionel@lionel-ubuntu:~$ echo 'La ruta de ls es: `which ls`'
La ruta de ls es: `which ls`
*** aca vemos que el command substitution pierde su significado

--------------------

VIDEO 36 - Escapando caracteres especiales

\ -> este caracter se denomina CARACTER DE ESCAPE vvv

lionel@lionel-ubuntu:~$ echo "esto es una expansion -> $(which cat), pero si la escapo con \\ pierde su significado -> \$(which cat)"
esto es una expansion -> /usr/bin/cat, pero si la escapo con \ pierde su significado -> $(which cat)

lionel@lionel-ubuntu:~$ ls -la nombre\ separado2.txt 
-rw-rw-r-- 1 lionel lionel 0 mar  2 22:44 'nombre separado2.txt'

*** equivalente a vvv
lionel@lionel-ubuntu:~$ ls -la "nombre separado2.txt" 
-rw-rw-r-- 1 lionel lionel 0 mar  2 22:44 'nombre separado2.txt'
lionel@lionel-ubuntu:~$ 

-e -> codigo de control vvv
---------------------------

lionel@lionel-ubuntu:~$ echo -e "\a"
*** le estamos transmitiendo la orden al ordenador de que haga un "bit" (un sonido)

lionel@lionel-ubuntu:~$ echo "\a"
\a

lionel@lionel-ubuntu:~$ echo -e "Este texto \t \a esta tabulado"
Este texto 	  esta tabulado
*** tabula texto y se escucha el "bit"

lionel@lionel-ubuntu:~$ echo "Este texto \t \a esta tabulado"
Este texto \t \a esta tabulado
*** texto plano

lionel@lionel-ubuntu:~$ echo -e "Esta es la primera linea con una \ttabulacion \nLuego hay un salto de linea, y finalmente se escuche el \a'bit'"
Esta es la primera linea con una 	tabulacion 
Luego hay un salto de linea, y finalmente se escuche el 'bit'
*** tabulacion, salti de linea y "bit"

lionel@lionel-ubuntu:~$ echo "Esta es la primera linea con una \ttabulacion \nLuego hay un salto de linea, y finalmente se escuche el \a'bit'"
Esta es la primera linea con una \ttabulacion \nLuego hay un salto de linea, y finalmente se escuche el \a'bit'
*** texto plano

\a \t \n \b \r vvv 

lionel@lionel-ubuntu:~$ echo -e "palabra1\a palabra2\t palabra3\n palabra4\b palabra5\r palabra6"
palabra1 palabra2	 palabra3
 palabra6palabra5

--------------------

VIDEO 37 - Caso práctico: El programa vulnerable persistente 

Ejercicio:
- Tenemos un programa instalado en /usr/bin (donde tenemos la mayoria de los programas que utilizamos dentro de nuestro SO Linux, dentro de nuestra shell)
- Uno de estos programas es vulnerable: tiene un fallo de seguridad cualquiera que se puede explotar para ganar por ejemplo una elevacion de privilegios, para poder convertirte en un usuario con mas privilegios. 
- el programa implementa una backdoor, el administrador en un momento se da cuenta que alguien externo esta explotando la falla, elimina con rm el script original pero no soluciona el problema porque el atacante al acceder al script creó un hard link.

- Definicion de backdoor (chatGTP):
Una puerta trasera, conocida en inglés como "backdoor", es una funcionalidad oculta o una vulnerabilidad en un software que permite el acceso no autorizado al sistema o a los datos por parte de personas no autorizadas. Las puertas traseras pueden ser insertadas intencionalmente por el creador del software con fines legítimos, como para facilitar el acceso de mantenimiento o para propósitos de pruebas, pero también pueden ser introducidas de manera maliciosa por personas que desean acceder de forma no autorizada.
Las puertas traseras pueden ser difíciles de detectar, ya que a menudo están diseñadas para pasar desapercibidas. Sin embargo, una vez que se descubren, pueden representar un riesgo significativo para la seguridad de un sistema, ya que pueden ser explotadas por hackers o personas malintencionadas para acceder a información confidencial, causar daños o comprometer la integridad del sistema.
En resumen, una puerta trasera en un programa es una forma de acceso no autorizado que puede ser explotada para comprometer la seguridad de un sistema o acceder a datos sensibles.

*** planteo original del ejercicio vvv 
https://www.hackinglinuxexposed.com/articles/20031214.html 

Simulacion vvv

V37.1) el administrador crea el script que va a tener la falla de seguridad 
lionel@lionel-ubuntu:~$ nano vulnprog
V37.2) escribí y guardé el archivo
#! /bin/bash

read -p "Introduce un valor de entrada: " entrada

if [ "$entrada" = "backdoor" ]; then
        echo "Proporcionaste shell de root"
else
        echo "Funcionamiento normal del programa"
fi

V37.3) intento ejecutarlo escribiendo vulnprog
lionel@lionel-ubuntu:~$ vulnprog
vulnprog: command not found

V37.4) intento ejecutarlo escribiendo ./vulnprog (sugerencia chatGTP)
lionel@lionel-ubuntu:~$ ./vulnprog
bash: ./vulnprog: Permission denied

V37.5) le damos permisos de ejecucion (lo saqué de los comentarios del video)
lionel@lionel-ubuntu:~$ chmod 777 vulnprog

V37.6) repito paso 3)
ionel@lionel-ubuntu:~$ vulnprog
vulnprog: command not found

V37.7) repito paso 4)
lionel@lionel-ubuntu:~$ ./vulnprog
Introduce un valor de entrada: inputcualquiera
Funcionamiento normal del programa

lionel@lionel-ubuntu:~$ ./vulnprog
Introduce un valor de entrada: backdoor
Proporcionaste shell de root

V37.8) copio el script en /usr/bin con permisos de administrador
lionel@lionel-ubuntu:~$ sudo cp vulnprog /usr/bin/
[sudo] password for lionel: 

V37.9) chequeo la existencia y los permisos de ambos archivos 
lionel@lionel-ubuntu:~$ ls -l vulnprog /usr/bin/vulnprog 
-rwxr-xr-x 1 root   root   191 mar  3 02:41 /usr/bin/vulnprog
-rwxrwxrwx 1 lionel lionel 191 mar  3 02:36 vulnprog

V37.10) creo un hard link de /usr/bin/vulnprog en ~
lionel@lionel-ubuntu:~$ sudo ln /usr/bin/vulnprog vulnprog.hardlink

V37.11) chequeo los inodos de los 2 archivos y del hard link
lionel@lionel-ubuntu:~$ ls -lai /usr/bin/vulnprog vulnprog vulnprog.hardlink 
1049104 -rwxr-xr-x 2 root   root   191 mar  3 02:41 /usr/bin/vulnprog
 535012 -rwxrwxrwx 1 lionel lionel 191 mar  3 02:36 vulnprog
1049104 -rwxr-xr-x 2 root   root   191 mar  3 02:41 vulnprog.hardlink
*** observar que /usr/bin/vulnprog y vulnprog.hardlink apuntan a los mismos espacios de memoria

V37.12) chequeo que el hard link funciona
lionel@lionel-ubuntu:~$ ./vulnprog.hardlink
Introduce un valor de entrada: backdoor
Proporcionaste shell de root

V37.13) elimino los 2 archivos dejando solo el hardlink 
lionel@lionel-ubuntu:~$ rm vulnprog  
lionel@lionel-ubuntu:~$ sudo rm /usr/bin/vulnprog 

V37.14) chequeo que se hayan borrado correctamente los 2 archivos y que aun exista el hard link
lionel@lionel-ubuntu:~$ ls -lai vulnprog.hardlink /usr/bin/vulnprog vulnprog
ls: cannot access '/usr/bin/vulnprog': No such file or directory
ls: cannot access 'vulnprog': No such file or directory
1049104 -rwxr-xr-x 1 root root 191 mar  3 02:41 vulnprog.hardlink
*** observar que solo quedo el hard link apuntando a los mismos espacios de memoria donde apuntaba tambien /usr/bin/vulnprog

V37.15) creo un nuevo /usr/bin/vulnprog solucionando la falla de seguridad
lionel@lionel-ubuntu:~$ sudo nano /usr/bin/vulnprog

#!/bin/bash
read -p "Introduce un valor de entrada: " entrada
echo "Funcionamiento normal del programa"

V37.16) verifico existencia y permisos del nuevo archivo y del hard link
lionel@lionel-ubuntu:~$ ls -lai /usr/bin/vulnprog vulnprog.hardlink 
1136253 -rw-r--r-- 1 root root 104 mar  3 02:57 /usr/bin/vulnprog
1049104 -rwxr-xr-x 1 root root 191 mar  3 02:41 vulnprog.hardlink

V37.17) doy permisos de ejecucion al nuevo script
lionel@lionel-ubuntu:~$ sudo chmod 777 /usr/bin/vulnprog 

V37.18) ejecuto el nuevo script y chequeo que se soluciono la falla de seguridad
lionel@lionel-ubuntu:~$ /usr/bin/vulnprog
Introduce un valor de entrada: backdoor
Funcionamiento normal del programa

V37.19) vuelvo a ejecutar el hardlink del script eliminado y compruebo que puedo seguir ejecutando el codigo fuente del script original y explotando las fallas de seguridad
lionel@lionel-ubuntu:~$ ./vulnprog.hardlink 
Introduce un valor de entrada: backdoor
Proporcionaste shell de root

--------------------

Prueba con script Python:

lionel@lionel-ubuntu:~$ nano app.py

print("Hola")

lionel@lionel-ubuntu:~$ ls -l app.py 
-rw-rw-r-- 1 lionel lionel 63 mar  3 03:12 app.py
lionel@lionel-ubuntu:~$ chmod 777 app.py 
lionel@lionel-ubuntu:~$ ls -l app.py 
-rwxrwxrwx 1 lionel lionel 63 mar  3 03:12 app.py

lionel@lionel-ubuntu:~$ ./app.py 
./app.py: line 1: syntax error near unexpected token `"Hola"'
./app.py: line 1: `print("Hola")'

*** No funcionó correctamente 

--------------------

VIDEO 39 - I/O Redirection 

- Input 
- Output 
- Redirection

- cuando ejecutamos el comando ls, este nos proporciona una salida

- normalmente, las utilidades que tenemos de la shell de linux, y en general, dentro de linux, van a sacarnos 2 tipos de informacion:
a) la propia informacion, es decir, los resultados del programa 
b) mensajes de estado y de error que nos van a indicar si el comportamiento del programa ha sido adecuado

lionel@lionel-ubuntu:~$ ls fichero_fantasma.txt
ls: cannot access 'fichero_fantasma.txt': No such file or directory
*** aqui ls nos muestra por pantalla informacion (en este caso, un mensaje de estado) que nos dice "no puedo acceder al fichero fichero_fantasma.txt porque este no existe en tu directorio actual"

Lo que ocurre por detras con todas estas utilidades para que generen las salidas 
-------------------------------------------------------
que nos proporcionan por pantalla vvv
-------------------------------------

- todos estos programitas, como por ejemplo ls, lo que estan haciendo para sacar la salida por pantalla, es escribir dicha salida en un fichero especial llamado stdout (/dev/stdout), que en realidad veremos que es un enlace simbolico a /proc/self/fd/1, y en ultima instancia a /dev/pts/0 vvv

lionel@lionel-ubuntu:~$ ls -lai /dev/stdout /dev/stdin /dev/stderr
391 lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stderr -> /proc/self/fd/2
389 lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdin -> /proc/self/fd/0
390 lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdout -> /proc/self/fd/1
*** como se ve en los 3 casos, la "l" antes de los permisos nos indica que en realidad son enlaces simbolicos 

- siguiendo el caminito de stdout vvv 

lionel@lionel-ubuntu:~$ ls -lai /dev/stdout
390 lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdout -> /proc/self/fd/1
*** enlace simbolico a /proc/self/fd/1

lionel@lionel-ubuntu:~$ ls -lai /proc/self/fd/1
109962 lrwx------ 1 lionel lionel 64 mar  3 13:15 /proc/self/fd/1 -> /dev/pts/0
*** enlace simbolico a /dev/pts/0

lionel@lionel-ubuntu:~$ ls -lai /dev/pts/0
3 crw--w---- 1 lionel tty 136, 0 mar  3 13:15 /dev/pts/0

- /dev/pts/0 es un tipo de fichero especial detro de linux
- observar que antes de los permisos viene referenciado con una "c", que indica que se trata de un CARACTER DEVICE FILE
- /dev/pts/0 es un tipo de fichero especial que va a servir de interfaz, en este caso con la terminal, y mas concretamente, con la pantalla
- es decir, va a recibir ciertos caracteres (por ejemplo el texto de salida que escribe y le envia la funcionalidad ls) y /dev/pts/0 va a mostrarlo por pantalla
- entonces /dev/pts/0 es un fichero especial al que nosotros le proporcionamos un texto, y que nos servira de interfaz, estara conectado con la pantalla de nuestro equipo, de nuestra terminal concretamente, y nos imprimira ese texto en la terminal

Flujo de salida:
a) ls ... -> escribe y envia texto a /dev/stdout
b) /dev/stdout, que es soft link a /proc/self/fd/1, redirecciona este texto 
c) /proc/self/fd/1, que es soft link a /dev/pts/0, redirecciona este texto
d) /dev/pts/0, que es un fichero especial, concretamente un CARACTER DEVICE FILE, que esta conectado a la pantalla de la terminal, imprimira el texto que originalmente genero la utilidad ls

- Por otro lado, los mensajes de estado y de error que pueda generar una utilidad se envian a /dev/stderr
*** uso el operador ";" para encadenar comandos y el caracter especial "\" para que sea mas legible (S2-TL-V12 curso Docker de holamundo) vvv

lionel@lionel-ubuntu:~$ \
> ls -lai /dev/stdout;\
> ls -lai /dev/stderr;\
> ls -lai /proc/self/fd/1;\
> ls -lai /proc/self/fd/2;\
> ls -lai /dev/pts/0
390 lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdout -> /proc/self/fd/1
391 lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stderr -> /proc/self/fd/2
239888 lrwx------ 1 lionel lionel 64 mar  3 14:25 /proc/self/fd/1 -> /dev/pts/0
239895 lrwx------ 1 lionel lionel 64 mar  3 14:25 /proc/self/fd/2 -> /dev/pts/0
3 crw--w---- 1 lionel tty 136, 0 mar  3  2024 /dev/pts/0
*** observar que tanto el enlace simbolico /dev/stdout como el enlace simbolico /dev/stderr, en ultima instancia apuntan al mismo fichero especial /dev/pts/0, y por lo tanto la interfaz va a ser exactamente la misma
*** por motivos de retrocompatibilidad, por motivos de diferenciar bien a donde vamos a mandar los mensajes de salida correctos y los mensajes de error, tenemos 2 enlaces simbolicos que son distintos (stderr para los mensajes de error y stdout para las salidas standard del propio comando) (con esto vemos cual es una de las funciones que tienen los enlaces simbolicos)

lionel@lionel-ubuntu:~$ tree -L 100 /dev/pts
/dev/pts
├── 0
├── 1
├── 2
├── 3
└── ptmx

0 directories, 5 files
*** observar que busque en 100 subniveles, entonces compruebo que /dev/pts/ solo contiene 5 ficheros

- Ademas de la salida standard y la salida de error, tenemos tambien entradas que son utiles para los comandos
- hay veces que ciertos comandos nos van a solicitar que nosotros metamos texto utilizando el teclado
- este tipo de entrada se denomina standard input que van a tener el fichero especial asociado /dev/stdin (que en verdad es un soft link que tambien apunta en ultima instancia a /dev/pts/0)

lionel@lionel-ubuntu:~$ \
> ls -lai /dev/stdin;\
> ls -lai /proc/self/fd/0;\
> ls -lai /dev/pts/0
389 lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdin -> /proc/self/fd/0
242736 lrwx------ 1 lionel lionel 64 mar  3 14:38 /proc/self/fd/0 -> /dev/pts/0
3 crw--w---- 1 lionel tty 136, 0 mar  3 14:38 /dev/pts/0

- curiosamente (como veremos en siguientes clases) este fichero especial /dev/pts/0 se encuentra tambien asociado con nuestro teclado y nos va a hacer de interfaz para que nosotros podamos presionar teclas (introducir texto por teclado) y el lo proporcione a ciertos comandos que reciben este standard input por parte del usuario

- una vez entendido que los programas van a redirigir el texto a stdout, stderr e incluso van a pedir los de stdin para que los introduzca el usuario veremos como modificar la salida standard (stdout), los estados errores (stderr) o los inputs (stdin), es decir redireccionar esas entradas y salidas hacia donde queramos

--------------------

VIDEO 40 - Standard Output (stdout) Redirection

Ahora que sabemos lo que pasa por detras cuando ejecutamos un comando en linux y su salida se muestra por pantalla, ahora veremos como podemos redirigir esa salida a donde a nosotros nos interese

Como controlar el standard output de un comando, es decir, la salida standard standard de un 
--------------------------------------------------------------------------------------------
comando vvv
-----------

\
ls fichero1.txt;\
ls -l fichero1.txt;\
ls -la fichero1.txt;\
ls -lah fichero1.txt;\
ls -lai fichero1.txt;

Operador redireccion (>)
------------------------

- el operador redireccion (>) nos permite redireccionar el standard output de un comando (no sirve para redirigir el stderr) vvv

lionel@lionel-ubuntu:~$ ls -lah > salida_ls.txt
lionel@lionel-ubuntu:~$ code salida_ls.txt 
*** en vez de mostrarse el stdout por pantalla, se creó el fichero salida_ls.txt con el stdout de ls -lah (luego, a modo de prueba, lo abrí con VSCode)
*** con esto hemos redireccionado la salida standard output del comando ls
*** esto mismo se puede aplicar a practicamente cualquier comando dentro de linux

lionel@lionel-ubuntu:~$ ls -l directorio_falso > salida_ls.txt 
ls: cannot access 'directorio_falso': No such file or directory
lionel@lionel-ubuntu:~$ cat salida_ls.txt 
lionel@lionel-ubuntu:~$ 
*** aca vemos que se mostro normalmente el stderr, ya que el operador > aplica solo para el stdout
*** tambien vemos que cuando redirigimos con >, el archivo de destino (si existe) siempre se va a reescribir dese el principio (o se va a crear y empezar a escribir desde el principio si no existe), entonces como ls en este caso no ha generado ningun resultado exitoso (ejecuto el stderr), la operacion de redireccion ha intentado empezar a reescribir el fichero salida_ls.txt, pero como no habia nada que escribir, se ha detenido, y ha provocado que el fichero se truncase (se pierdan los datos anteriores)

lionel@lionel-ubuntu:~$ > nuevofichero.txt
lionel@lionel-ubuntu:~$ cat nuevofichero.txt 
lionel@lionel-ubuntu:~$ ls -l nuevofichero.txt 
-rw-rw-r-- 1 lionel lionel 0 mar  3 17:08 nuevofichero.txt
*** otro ejemplo, con el que vemos que es una forma de crear un ficher vacio (observar que pesa 0 bits)

*** conclusion: el operador > siempre va a truncar el contenido previo del fichero de destino

>>: este operador evita que se trunque el contenido original del archivo de destino vvv

lionel@lionel-ubuntu:~$ ls -lah > salida_ls.txt 
lionel@lionel-ubuntu:~$ tail -n 2 salida_ls.txt 
drwxrwxr-x  4 lionel lionel 4,0K feb 17 17:02 .vscode
-rwxr-xr-x  1 root   root    191 mar  3 02:41 vulnprog.hardlink
lionel@lionel-ubuntu:~$ echo "linea nueva" >> salida_ls.txt 
lionel@lionel-ubuntu:~$ tail -n 2 salida_ls.txt 
-rwxr-xr-x  1 root   root    191 mar  3 02:41 vulnprog.hardlink
linea nueva
*** como vemos, con >> la linea nueva se agrego al final del contenido previo del fichero de destino, sin truncarlo

--------------------

VIDEO 41 - Standard Error (stderr) Redirection

- los operadores > y >> solo sirven para stdoutput 

- entonces, como no existen operadores especiales para redireccionar el stderr, vamos a hacerlo utilizando una estructura dentro del sistema de ficheros que es muy importante, y que utiliza el kernel de linux para poder gestionar adecuadamente los ficheros abiertos, que se denomina FILE DESCRIPTOR

File Descriptor (descriptor de ficheros):  

- file descriptor es algo que tiene sentido cuando se abre un fichero
- cuando un proceso cualquiera abre un fichero, es decir, realiza una peticion al kernel para que se abra un fichero (para empezar a leerlo, para empezar a escribirlo, etc) el kernel lo que va a hacer es retornarle (al proceso) un descriptor de fichero, que es un numerito que va a identificar a ese fichero que se esta abriendo.
- el descriptor de fichero, al mismo tiempo, va a apuntar a una tabla que se llama GLOBAL FILE TABLE, es decir, una tabla de ficheros global que maneja el kernel,y que va a tener ciertas cosas importantes, como por ejemplo:
* informacion sobre el inodo del fichero que se ha abierto 
* las restricciones de acceso a ese fichero 
- con lo cual, cuando tu quieras consumirlo, dependiendo del descriptor que tengas y dependiendo de lo que aparezca en esa tabla global de ficheros, el kernel te va a dejar realizar unas acciones sobre ese fichero que esta abierto u otras acciones diferentes.

- entonces, como vimos, el stdout, el stderr y el stdinput (soft links) apuntan en ultima instancia al mismo fichero especial /dev/pts/0, pero lo que cambia entre ellos es el file descriptor 
* el stdoutput tiene un file descriptor asociado
* el stderr tiene un file descriptor asociado
* el stdinput tiene un file descriptor asociado
- que apuntan a esta entrada en la global file table donde tendran una serie de restricciones de acceso y donde se indica que uno sirve para redireccionar salida, otro sirve para redireccionar error y otro sirve para redireccionar entrada

- lo interesante es que sepamos cual es el file descriptor de un fichero vvv

lionel@lionel-ubuntu:~$ ls -l /dev/stdout 
lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdout -> /proc/self/fd/1
*** podemos ver en este ficherito (/proc/self/fd) al que esta apuntando el enlace simbolico /dev/stdout que el file descriptor es el 1

lionel@lionel-ubuntu:~$ \
ls -l /dev/stdout;\
ls -l /dev/stderr;\
ls -l /dev/stdin;
lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdout -> /proc/self/fd/1
lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stderr -> /proc/self/fd/2
lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stdin -> /proc/self/fd/0
*** file descriptor stdin = 0
*** file descriptor stdout = 1
*** file descriptor stderr = 2

*** como vemos, la informacion del file descriptor de cada uno de estos ficheros se encuentra en el directorio /proc, que como vimos consiste en un sistema de ficheros virtual que se va a creando con todos los procesos que tenemos arrancados en ese momento

*** entonces probablemente, si queremos saber el file descriptor de cualquier otro archivo que esta abierto en un momento determinado tendremos que ir a buscarlo dentro de "/proc/" + el PID de ese proceso (veremos mas adelante el tema de los PID)  + "/" , y dentro de ese proceso que esta en ejecucion tendra abierto un fichero, y como lo tiene abierto tendra un file descriptor asociado

REPASO DEL DIRECTORIO /proc vvv

*** este directorio esta administrado por el sistema, no debemos tocar nada de lo que hay dentro
*** si tiramos un ls en /proc vamos a obtener una interfaz con el Kernel
*** aqui vamos a obtener un monton de informacion sobre como esta funcionando el Kernel y los dispositivos hardware que tenemos en nuestra maquina
*** tenemos por ejemplo ficheros como filesystems que nos da informacion sobre los sistemas de ficheros que tenemos cargados 
*** meminfo de informacion sobre la memoria
*** tenemos varios ficheros que nos van a dar informacion sobre el hardware y el funcionamiento del kernel
*** tenemos tambien cpuinfo sobre la cpu 
*** tenemos tambien directorios con diferentes numeros 
*** estos numeros son PIDs, pero basicamente son identificadores de procesos 
*** cada uno de los procesos que tenemos tiene un directorio asociado dentro de /proc que contiene informacion sobre el estado en el que se encuentra en este momento, como se ha ejecutado, etc.
*** lo que vemos dentro de /proc no es un sistema de ficheros propiamente dicho sino que se suele llamar sistema de ficheros virtual porque esta como creado sobre la marcha, en tiempo de ejecucion 

*** si hacemos un ls -la /proc comprobamos que la mayoria de los los archivos y directorios continenen 0 bits

lionel@lionel-ubuntu:/proc$ echo $$
2360
*** esto me da el PID del proceso actual, que seria la propia shell, que es un proceso dentro de nuestro SO

lionel@lionel-ubuntu:/proc$ cd 2360
*** entro al directorio del proceso

lionel@lionel-ubuntu:/proc/2360$ ls -la .
*** comprobamos que todos los archivos que figuran dentro tienen 0 bits 

*** por eso es que se llama a lo que hay dentro de /proc un sistema de ficheros virtual, no es propiamente un sistema de ficheros

lionel@lionel-ubuntu:/proc/2360$ less status
*** con este comando podemos ver el estado de nuestro proceso (del 2360, status es un fichero dentro de /proc/2360)

Ahora veremos como redirigir el stderr haciendo uso de este file descriptor vvv 

lionel@lionel-ubuntu:~$ ls -la /dev/stderr 
lrwxrwxrwx 1 root root 15 mar  3 12:15 /dev/stderr -> /proc/self/fd/2
*** file descriptor stderr = 2

lionel@lionel-ubuntu:~$ ls -l directorio_inexistente 2> error_ls.txt
*** redirijo el psible error
*** le estoy indicando que en caso de error, lo que deberia ir al standard error (file descriptor 2), lo redirija a error_ls.txt

lionel@lionel-ubuntu:~$ cat error_ls.txt 
ls: cannot access 'directorio_inexistente': No such file or directory
lionel@lionel-ubuntu:~$ code error_ls.txt 
*** compruebo que el error se redirecciono correctamente a donde queria (luego lo abro en VSCode)

- Forma de redirigir el stdout o el stderr indistintamente al mismo fichero destino vvv
---------------------------------------------------------------------------------------

lionel@lionel-ubuntu:~$ \
ls -l dir1/ >> ls-salida.txt 2>&1;\
ls -l dir19/ >> ls-salida.txt 2>&1;\
ls -l dir2/ >> ls-salida.txt 2>&1;\
ls -l dir29/ >> ls-salida.txt 2>&1;\
cat ls-salida.txt 
total 0
-rw-rw-r-- 1 lionel lionel 0 mar  3 20:38 ficheroA.txt
-rw-rw-r-- 1 lionel lionel 0 mar  3 20:39 ficheroB.txt
ls: cannot access 'dir19/': No such file or directory
total 0
-rw-rw-r-- 1 lionel lionel 0 mar  3 20:41 ficheroQ.txt
-rw-rw-r-- 1 lionel lionel 0 mar  3 20:41 ficheroR.txt
ls: cannot access 'dir29/': No such file or directory

*** con e operador "2>&1" estoy indicando que, en caso de error, este se redirija al mismo fichero destino previo a dicho operador
*** lo que estamos indicando con este operador es que queremos que redirija el descriptor 2 (el stderr) al file descriptor 1 (stdoutput)
*** entonces lo que realmente esta pasando es que el stderr se redirije al stdoutput, y el stdoutput lo redirijimos a ls-salida.txt, con lo que el stdoutput como el stderr se redirigen al mismo fichero destino

*** en versiones modernas de la shell contamos con el operador &> (o &>>) que de manera mas sencilla nos permite redirigir tanto el stdoutput como el stderr al mismo fichero de destino vvv 

lionel@lionel-ubuntu:~$ \
ls -l dir1/ &>> ls-salida.txt;\
ls -l dir19/ &>> ls-salida.txt;\
ls -l dir2/ &>> ls-salida.txt;\
ls -l dir29/ &>> ls-salida.txt